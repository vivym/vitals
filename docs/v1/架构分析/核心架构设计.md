# 核心架构设计

## 1. 架构概览

### 1.1 整体架构原则
- **分层架构**: 采用经典的分层架构模式，确保关注点分离
- **依赖注入**: 使用 Riverpod 实现依赖注入和状态管理
- **数据驱动**: 基于不可变数据模型（Freezed）的响应式编程
- **测试驱动开发**: 严格遵循 TDD 范式，先写测试后写实现

### 1.2 技术栈
- **状态管理**: flutter_riverpod + hooks_riverpod + flutter_hooks
- **网络层**: dio (生产) + mock (测试/开发)
- **数据模型**: freezed + json_annotation
- **UI 组件**: 基于 Material Design 3 + 自定义组件
- **路由**: go_router (结合 Riverpod)
- **本地存储**: shared_preferences (轻量级) + secure_storage (敏感数据)

## 2. 项目文件结构

```
lib/
├── main.dart                    # 应用入口
├── app/                         # 应用级配置
│   ├── app.dart                # 主应用组件
│   ├── router/                 # 路由配置
│   └── themes/                 # 主题配置
├── core/                       # 核心基础设施
│   ├── network/               # 网络层
│   ├── storage/               # 存储层
│   ├── utils/                 # 工具类
│   ├── constants/             # 常量定义
│   └── errors/                # 错误处理
├── shared/                     # 共享组件和模型
│   ├── models/               # 共享数据模型
│   ├── widgets/              # 共享UI组件
│   ├── providers/            # 共享状态提供者
│   └── extensions/           # 扩展方法
├── features/                   # 功能模块
│   ├── auth/                  # 用户认证
│   ├── dashboard/             # 首页
│   ├── health_data/           # 健康数据
│   ├── profile/               # 个人中心
│   └── reports/               # 健康报告
└── test/                      # 测试文件
    ├── unit/                  # 单元测试
    ├── widget/                # 组件测试
    └── integration/           # 集成测试
```

每个 feature 模块内部结构：
```
features/[module_name]/
├── data/                      # 数据层
│   ├── models/               # 数据模型
│   ├── repositories/         # 仓库实现
│   └── datasources/          # 数据源（API/本地）
├── domain/                   # 业务逻辑层
│   ├── entities/            # 业务实体
│   ├── repositories/        # 仓库接口
│   └── usecases/            # 用例
├── presentation/            # 表现层
│   ├── screens/            # 页面
│   ├── widgets/            # 组件
│   └── providers/          # 状态提供者
└── test/                   # 模块测试
```

## 3. 状态管理架构 (Riverpod)

### 3.1 Provider 分类与职责

```dart
// 1. Repository Providers - 数据仓库
@riverpod
AuthRepository authRepository(AuthRepositoryRef ref) =>
    AuthRepositoryImpl(ref.watch(apiClientProvider));

// 2. UseCase Providers - 业务用例
@riverpod
class LoginUseCase extends _$LoginUseCase {
  Future<void> login(String phone) async {
    // 业务逻辑实现
  }
}

// 3. State Notifier Providers - 页面状态管理
@riverpod
class AuthNotifier extends _$AuthNotifier {
  @override
  AsyncValue<AuthState> build() => const AsyncValue.loading();

  Future<void> login(String phone) async {
    // 状态变更逻辑
  }
}

// 4. Computed Providers - 派生状态
@riverpod
bool isLoggedIn(IsLoggedInRef ref) {
  final authState = ref.watch(authNotifierProvider);
  return authState.maybeWhen(
    data: (state) => state.isAuthenticated,
    orElse: () => false,
  );
}
```

### 3.2 状态生命周期管理

```dart
// 自动清理策略
@riverpod
class SomeNotifier extends _$SomeNotifier {
  @override
  AsyncValue<SomeState> build() {
    // 监听认证状态，用户登出时自动清理
    ref.listen(authNotifierProvider, (previous, next) {
      next.maybeWhen(
        data: (authState) {
          if (!authState.isAuthenticated) {
            ref.invalidateSelf(); // 清理当前状态
          }
        },
        orElse: () {},
      );
    });

    return loadInitialData();
  }

  @override
  void dispose() {
    // 清理资源
    super.dispose();
  }
}
```

## 4. 网络层架构

### 4.1 网络客户端配置

```dart
// API 客户端接口
abstract class ApiClient {
  Future<T> get<T>(String path, {Map<String, dynamic>? queryParameters});
  Future<T> post<T>(String path, {dynamic data});
  Future<T> put<T>(String path, {dynamic data});
  Future<T> delete<T>(String path);
}

// Dio 实现
class DioApiClient implements ApiClient {
  final Dio _dio;

  DioApiClient({required String baseUrl}) : _dio = Dio() {
    _setupInterceptors();
  }

  void _setupInterceptors() {
    // 请求拦截器 - 添加认证 token
    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) async {
        final token = await _getStoredToken();
        if (token != null) {
          options.headers['Authorization'] = 'Bearer $token';
        }
        handler.next(options);
      },
      onError: (error, handler) async {
        // 401 认证失败处理
        if (error.response?.statusCode == 401) {
          await _handleAuthFailure();
        }
        handler.next(error);
      },
    ));
  }
}

// Mock 实现（用于测试和开发）
class MockApiClient implements ApiClient {
  final Map<String, dynamic> _mockData;
  final Duration _delay;

  MockApiClient({
    required Map<String, dynamic> mockData,
    Duration delay = const Duration(milliseconds: 500),
  }) : _mockData = mockData, _delay = delay;

  @override
  Future<T> get<T>(String path, {Map<String, dynamic>? queryParameters}) async {
    await Future.delayed(_delay);
    // 根据路径返回对应的 mock 数据
    return _mockData[path] as T;
  }
}
```

### 4.2 环境配置

```dart
// 环境配置
enum Environment { development, staging, production }

@riverpod
Environment currentEnvironment(CurrentEnvironmentRef ref) {
  // 根据编译常量或配置文件确定环境
  return Environment.development;
}

@riverpod
ApiClient apiClient(ApiClientRef ref) {
  final environment = ref.watch(currentEnvironmentProvider);

  switch (environment) {
    case Environment.development:
      return MockApiClient(mockData: MockDataConfig.all);
    case Environment.staging:
    case Environment.production:
      return DioApiClient(baseUrl: Config.apiBaseUrl);
  }
}
```

## 5. 数据模型架构 (Freezed)

### 5.1 数据模型定义规范

```dart
// 基础实体模型
@freezed
class User with _$User {
  const factory User({
    required String id,
    required String name,
    required String phone,
    String? email,
    @Default(false) bool isActive,
    @JsonKey(name: 'created_at') DateTime? createdAt,
    @JsonKey(name: 'updated_at') DateTime? updatedAt,
  }) = _User;

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}

// 状态模型
@freezed
class AuthState with _$AuthState {
  const factory AuthState({
    User? user,
    String? token,
    @Default(false) bool isAuthenticated,
    @Default(false) bool isLoading,
    String? error,
  }) = _AuthState;

  // 便利方法
  const AuthState._();

  bool get hasError => error != null;
  bool get isReady => !isLoading && error == null;
}

// API 响应模型
@freezed
class ApiResponse<T> with _$ApiResponse<T> {
  const factory ApiResponse({
    required bool success,
    required T data,
    String? message,
    int? code,
  }) = _ApiResponse<T>;

  factory ApiResponse.fromJson(
    Map<String, dynamic> json,
    T Function(Object?) fromJsonT,
  ) => _$ApiResponseFromJson<T>(json, fromJsonT);
}
```

### 5.2 Union Types 错误处理

```dart
// 结果类型（类似 Rust 的 Result）
@freezed
class Result<T, E> with _$Result<T, E> {
  const factory Result.success(T data) = Success<T, E>;
  const factory Result.failure(E error) = Failure<T, E>;
}

// 应用错误类型
@freezed
class AppError with _$AppError {
  const factory AppError.network({
    required String message,
    int? statusCode,
  }) = NetworkError;

  const factory AppError.validation({
    required String field,
    required String message,
  }) = ValidationError;

  const factory AppError.authentication({
    required String message,
  }) = AuthenticationError;

  const factory AppError.unknown({
    required String message,
    Object? cause,
  }) = UnknownError;
}
```

## 6. 路由架构

### 6.1 路由配置

```dart
// 路由路径常量
class AppRoutes {
  static const splash = '/';
  static const login = '/login';
  static const dashboard = '/dashboard';
  static const profile = '/profile';
  static const healthData = '/health-data';
  static const reports = '/reports';
}

// 路由配置
@riverpod
GoRouter appRouter(AppRouterRef ref) {
  final authState = ref.watch(authNotifierProvider);

  return GoRouter(
    initialLocation: AppRoutes.splash,
    redirect: (context, state) {
      final isLoggedIn = authState.maybeWhen(
        data: (state) => state.isAuthenticated,
        orElse: () => false,
      );

      // 路由重定向逻辑
      if (!isLoggedIn && !_isPublicRoute(state.location)) {
        return AppRoutes.login;
      }

      if (isLoggedIn && state.location == AppRoutes.login) {
        return AppRoutes.dashboard;
      }

      return null;
    },
    routes: [
      GoRoute(
        path: AppRoutes.splash,
        builder: (context, state) => const SplashScreen(),
      ),
      GoRoute(
        path: AppRoutes.login,
        builder: (context, state) => const LoginScreen(),
      ),
      GoRoute(
        path: AppRoutes.dashboard,
        builder: (context, state) => const DashboardScreen(),
      ),
      // ... 其他路由
    ],
  );
}
```

## 7. TDD 测试架构

### 7.1 测试分层策略

```dart
// 1. 单元测试 - 业务逻辑测试
void main() {
  group('AuthRepository', () {
    late AuthRepository repository;
    late MockApiClient mockApiClient;

    setUp(() {
      mockApiClient = MockApiClient();
      repository = AuthRepositoryImpl(mockApiClient);
    });

    test('should return success when login with valid credentials', () async {
      // Given
      const phone = '13800000000';
      final expectedResponse = AuthResponse(
        token: 'test_token',
        user: User(id: '1', name: 'Test User', phone: phone),
      );

      when(() => mockApiClient.post('/auth/mock-login', data: any(named: 'data')))
          .thenAnswer((_) async => expectedResponse);

      // When
      final result = await repository.login(phone);

      // Then
      expect(result.isSuccess, true);
      expect(result.data.token, 'test_token');
    });
  });
}

// 2. Widget 测试 - UI 组件测试
void main() {
  testWidgets('LoginScreen should show login button', (tester) async {
    // Given
    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          authNotifierProvider.overrideWith(() => MockAuthNotifier()),
        ],
        child: MaterialApp(home: LoginScreen()),
      ),
    );

    // When & Then
    expect(find.text('一键登录'), findsOneWidget);
    expect(find.byType(ElevatedButton), findsOneWidget);
  });
}

// 3. 集成测试 - 端到端流程测试
void main() {
  group('Authentication Flow', () {
    testWidgets('complete login flow', (tester) async {
      // Given
      await tester.pumpWidget(MyApp());

      // When - 用户点击登录按钮
      await tester.tap(find.text('一键登录'));
      await tester.pumpAndSettle();

      // Then - 应该跳转到首页
      expect(find.byType(DashboardScreen), findsOneWidget);
    });
  });
}
```

### 7.2 Mock 和测试工具

```dart
// Provider 覆写用于测试
final testContainer = ProviderContainer(
  overrides: [
    apiClientProvider.overrideWithValue(MockApiClient()),
    authRepositoryProvider.overrideWith((ref) => MockAuthRepository()),
  ],
);

// 测试辅助工具
class TestHelper {
  static Widget wrapWithProviders(
    Widget child, {
    List<Override> overrides = const [],
  }) {
    return ProviderScope(
      overrides: overrides,
      child: MaterialApp(home: child),
    );
  }

  static Future<void> pumpWithProviders(
    WidgetTester tester,
    Widget widget, {
    List<Override> overrides = const [],
  }) async {
    await tester.pumpWidget(wrapWithProviders(widget, overrides: overrides));
  }
}
```

## 8. 错误处理和日志

### 8.1 全局错误处理

```dart
// 全局错误处理器
@riverpod
class GlobalErrorHandler extends _$GlobalErrorHandler {
  @override
  void build() {
    // 监听所有 provider 的错误
    ref.container.observers.add(ErrorObserver());
  }

  void handleError(Object error, StackTrace stackTrace) {
    // 日志记录
    Logger.error('Global error occurred', error, stackTrace);

    // 错误上报
    if (kReleaseMode) {
      CrashReporting.recordError(error, stackTrace);
    }

    // UI 错误提示
    _showErrorToUser(error);
  }
}

// Provider 错误观察者
class ErrorObserver extends ProviderObserver {
  @override
  void didUpdateProvider(
    ProviderBase provider,
    Object? previousValue,
    Object? newValue,
    ProviderContainer container,
  ) {
    if (newValue is AsyncError) {
      container.read(globalErrorHandlerProvider.notifier)
          .handleError(newValue.error, newValue.stackTrace);
    }
  }
}
```

## 9. 性能优化策略

### 9.1 状态管理优化

```dart
// 1. 使用 select 避免不必要的重建
class MyWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 只监听特定字段变化
    final isLoading = ref.watch(
      authNotifierProvider.select((state) => state.isLoading),
    );

    return isLoading ? LoadingWidget() : ContentWidget();
  }
}

// 2. 使用 family 实现细粒度缓存
@riverpod
Future<HealthData> healthData(HealthDataRef ref, String patientId, DateRange range) async {
  // 自动缓存不同参数组合的结果
  return ref.watch(healthDataRepositoryProvider).getHealthData(patientId, range);
}
```

### 9.2 UI 性能优化

```dart
// 1. 使用 const 构造函数
class OptimizedWidget extends StatelessWidget {
  const OptimizedWidget({super.key, required this.data});

  final String data;

  @override
  Widget build(BuildContext context) {
    return const Text('Static content'); // const 构造
  }
}

// 2. 列表性能优化
class OptimizedListView extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final items = ref.watch(itemsProvider);

    return ListView.builder(
      itemCount: items.length,
      itemBuilder: (context, index) {
        // 使用 key 提升性能
        return OptimizedListItem(
          key: ValueKey(items[index].id),
          item: items[index],
        );
      },
    );
  }
}
```

## 10. 开发工作流

### 10.1 TDD 开发流程

1. **Red**: 先写失败的测试
2. **Green**: 编写最简实现让测试通过
3. **Refactor**: 重构代码保持测试通过

```bash
# 开发流程命令
flutter test --watch                    # 持续测试
flutter pub run build_runner watch     # 代码生成监听
flutter analyze                        # 代码分析
flutter test --coverage               # 测试覆盖率
```

### 10.2 代码质量保证

```yaml
# analysis_options.yaml
linter:
  rules:
    - always_declare_return_types
    - prefer_const_constructors
    - sort_constructors_first
    - use_super_parameters
    # ... 更多规则
```

这个核心架构设计为整个应用提供了统一的技术基础，其他功能模块将基于这个架构进行开发。
