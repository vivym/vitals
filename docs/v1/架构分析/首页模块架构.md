# 首页（Dashboard）模块架构设计

## 1. 模块概述

### 1.1 功能描述
首页模块是用户登录后的主要入口，提供健康数据概览、康复目标跟踪和健康教育内容，帮助用户快速了解当前健康状况和康复进度。

### 1.2 核心功能
- **健康数据概览**: 展示心率、血压、体重、步数等核心健康指标的今日/最近数据
- **康复目标管理**: 显示和跟踪血压控制、胆固醇水平、运动目标、用药依从性等康复目标
- **健康宣教**: 推荐健康知识文章、视频，支持阅读状态跟踪
- **快速操作**: 提供快捷入口到各个功能模块

### 1.3 技术要求
- 基于 TDD 开发模式
- 支持下拉刷新和自动刷新
- 优化列表性能和数据缓存
- 响应式设计适配不同屏幕尺寸

## 2. 数据模型设计

### 2.1 核心实体模型

```dart
// 健康数据概览
@freezed
class HealthDataOverview with _$HealthDataOverview {
  const factory HealthDataOverview({
    BloodPressureSummary? bloodPressure,
    HeartRateSummary? heartRate,
    WeightSummary? weight,
    StepsSummary? steps,
    @JsonKey(name: 'last_updated') DateTime? lastUpdated,
  }) = _HealthDataOverview;

  factory HealthDataOverview.fromJson(Map<String, dynamic> json) =>
      _$HealthDataOverviewFromJson(json);
}

// 血压概览数据
@freezed
class BloodPressureSummary with _$BloodPressureSummary {
  const factory BloodPressureSummary({
    required int systolic,      // 收缩压
    required int diastolic,     // 舒张压
    required DateTime recordedAt,
    BloodPressureLevel? level,  // 血压水平评估
    String? trend,             // 趋势：rising, falling, stable
  }) = _BloodPressureSummary;

  factory BloodPressureSummary.fromJson(Map<String, dynamic> json) =>
      _$BloodPressureSummaryFromJson(json);
}

// 血压水平枚举
@JsonEnum(valueField: 'value')
enum BloodPressureLevel {
  normal(1, '正常', Color(0xFF4CAF50)),
  elevated(2, '血压偏高', Color(0xFFFF9800)),
  stage1(3, '1级高血压', Color(0xFFFF5722)),
  stage2(4, '2级高血压', Color(0xFFF44336)),
  crisis(5, '高血压危象', Color(0xFF9C27B0));

  const BloodPressureLevel(this.value, this.label, this.color);
  final int value;
  final String label;
  final Color color;
}

// 心率概览数据
@freezed
class HeartRateSummary with _$HeartRateSummary {
  const factory HeartRateSummary({
    required int bpm,
    required DateTime recordedAt,
    HeartRateZone? zone,
    String? trend,
  }) = _HeartRateSummary;

  factory HeartRateSummary.fromJson(Map<String, dynamic> json) =>
      _$HeartRateSummaryFromJson(json);
}

// 心率区间
@JsonEnum(valueField: 'value')
enum HeartRateZone {
  resting(1, '静息', Color(0xFF2196F3)),
  fat_burn(2, '燃脂', Color(0xFF4CAF50)),
  cardio(3, '有氧', Color(0xFFFF9800)),
  peak(4, '无氧', Color(0xFFFF5722));

  const HeartRateZone(this.value, this.label, this.color);
  final int value;
  final String label;
  final Color color;
}

// 体重概览数据
@freezed
class WeightSummary with _$WeightSummary {
  const factory WeightSummary({
    required double weight,     // 单位：kg
    required DateTime recordedAt,
    double? bmi,
    BMICategory? bmiCategory,
    String? trend,
  }) = _WeightSummary;

  factory WeightSummary.fromJson(Map<String, dynamic> json) =>
      _$WeightSummaryFromJson(json);
}

// BMI 分类
@JsonEnum(valueField: 'value')
enum BMICategory {
  underweight(1, '偏瘦', Color(0xFF2196F3)),
  normal(2, '正常', Color(0xFF4CAF50)),
  overweight(3, '偏胖', Color(0xFFFF9800)),
  obese(4, '肥胖', Color(0xFFFF5722));

  const BMICategory(this.value, this.label, this.color);
  final int value;
  final String label;
  final Color color;
}

// 步数概览数据
@freezed
class StepsSummary with _$StepsSummary {
  const factory StepsSummary({
    required int steps,
    required DateTime date,
    int? goal,
    double? calories,
    double? distance,    // 单位：km
  }) = _StepsSummary;

  factory StepsSummary.fromJson(Map<String, dynamic> json) =>
      _$StepsSummaryFromJson(json);

  const StepsSummary._();

  double get goalProgress => goal != null && goal! > 0 ? steps / goal! : 0.0;
  bool get goalAchieved => goalProgress >= 1.0;
}

// 康复目标
@freezed
class RecoveryGoal with _$RecoveryGoal {
  const factory RecoveryGoal({
    required String id,
    required String title,
    required String description,
    required GoalType type,
    required double targetValue,
    required double currentValue,
    required String unit,
    @JsonKey(name: 'start_date') required DateTime startDate,
    @JsonKey(name: 'end_date') required DateTime endDate,
    @Default(GoalStatus.active) GoalStatus status,
    @JsonKey(name: 'created_at') DateTime? createdAt,
  }) = _RecoveryGoal;

  factory RecoveryGoal.fromJson(Map<String, dynamic> json) =>
      _$RecoveryGoalFromJson(json);

  const RecoveryGoal._();

  double get progress => targetValue > 0 ? currentValue / targetValue : 0.0;
  bool get isCompleted => progress >= 1.0;
  bool get isExpired => DateTime.now().isAfter(endDate);

  int get daysRemaining {
    final now = DateTime.now();
    if (now.isAfter(endDate)) return 0;
    return endDate.difference(now).inDays;
  }
}

// 目标类型
@JsonEnum(valueField: 'value')
enum GoalType {
  blood_pressure(1, '血压控制', Icons.favorite, Color(0xFFE91E63)),
  cholesterol(2, '胆固醇', Icons.water_drop, Color(0xFF2196F3)),
  exercise(3, '运动目标', Icons.directions_run, Color(0xFF4CAF50)),
  medication(4, '用药依从性', Icons.medication, Color(0xFFFF9800)),
  weight(5, '体重管理', Icons.monitor_weight, Color(0xFF9C27B0));

  const GoalType(this.value, this.label, this.icon, this.color);
  final int value;
  final String label;
  final IconData icon;
  final Color color;
}

// 目标状态
@JsonEnum(valueField: 'value')
enum GoalStatus {
  active(1, '进行中'),
  completed(2, '已完成'),
  paused(3, '已暂停'),
  cancelled(4, '已取消');

  const GoalStatus(this.value, this.label);
  final int value;
  final String label;
}

// 健康教育内容
@freezed
class HealthEducationItem with _$HealthEducationItem {
  const factory HealthEducationItem({
    required String id,
    required String title,
    required String summary,
    required String content,
    required EducationType type,
    String? imageUrl,
    String? videoUrl,
    required int readingTime,    // 预计阅读时间（分钟）
    @Default([]) List<String> tags,
    @JsonKey(name: 'published_at') required DateTime publishedAt,
    @Default(false) bool isRead,
    @Default(false) bool isFavorited,
  }) = _HealthEducationItem;

  factory HealthEducationItem.fromJson(Map<String, dynamic> json) =>
      _$HealthEducationItemFromJson(json);
}

// 教育内容类型
@JsonEnum(valueField: 'value')
enum EducationType {
  article(1, '文章', Icons.article),
  video(2, '视频', Icons.play_circle),
  infographic(3, '图解', Icons.image);

  const EducationType(this.value, this.label, this.icon);
  final int value;
  final String label;
  final IconData icon;
}

// 首页状态
@freezed
class DashboardState with _$DashboardState {
  const factory DashboardState({
    HealthDataOverview? healthData,
    @Default([]) List<RecoveryGoal> recoveryGoals,
    @Default([]) List<HealthEducationItem> educationItems,
    @Default(false) bool isLoading,
    @Default(false) bool isRefreshing,
    String? error,
    @JsonKey(name: 'last_updated') DateTime? lastUpdated,
  }) = _DashboardState;

  const DashboardState._();

  bool get hasError => error != null;
  bool get hasData => healthData != null || recoveryGoals.isNotEmpty;
  bool get isEmpty => !hasData && !isLoading;

  List<RecoveryGoal> get activeGoals => recoveryGoals
      .where((goal) => goal.status == GoalStatus.active)
      .toList();

  List<HealthEducationItem> get unreadEducation => educationItems
      .where((item) => !item.isRead)
      .toList();
}
```

### 2.2 API 响应模型

```dart
// 首页聚合数据响应
@freezed
class DashboardResponse with _$DashboardResponse {
  const factory DashboardResponse({
    required HealthDataOverview healthData,
    required List<RecoveryGoal> recoveryGoals,
    required List<HealthEducationItem> educationItems,
    @JsonKey(name: 'last_updated') DateTime? lastUpdated,
  }) = _DashboardResponse;

  factory DashboardResponse.fromJson(Map<String, dynamic> json) =>
      _$DashboardResponseFromJson(json);
}

// 教育内容阅读状态更新请求
@freezed
class UpdateEducationStatusRequest with _$UpdateEducationStatusRequest {
  const factory UpdateEducationStatusRequest({
    required String itemId,
    required bool isRead,
    bool? isFavorited,
  }) = _UpdateEducationStatusRequest;

  factory UpdateEducationStatusRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdateEducationStatusRequestFromJson(json);
}
```

## 3. 数据层架构

### 3.1 数据源接口

```dart
// 首页远程数据源接口
abstract class DashboardRemoteDataSource {
  Future<DashboardResponse> getDashboardData(String patientId);
  Future<HealthDataOverview> getHealthDataOverview(String patientId);
  Future<List<RecoveryGoal>> getRecoveryGoals(String patientId);
  Future<List<HealthEducationItem>> getEducationItems({
    int page = 1,
    int limit = 10,
  });
  Future<void> updateEducationStatus(UpdateEducationStatusRequest request);
  Future<void> markEducationAsRead(String itemId);
  Future<void> toggleEducationFavorite(String itemId, bool isFavorited);
}

// 首页本地数据源接口
abstract class DashboardLocalDataSource {
  Future<DashboardResponse?> getCachedDashboard(String patientId);
  Future<void> cacheDashboard(String patientId, DashboardResponse data);
  Future<void> clearCache(String patientId);
  Future<List<String>> getReadEducationIds();
  Future<void> markEducationAsRead(String itemId);
  Future<List<String>> getFavoritedEducationIds();
  Future<void> toggleEducationFavorite(String itemId, bool isFavorited);
}
```

### 3.2 数据源实现

```dart
// Dio 远程数据源实现
class DashboardRemoteDataSourceImpl implements DashboardRemoteDataSource {
  final ApiClient _apiClient;

  DashboardRemoteDataSourceImpl(this._apiClient);

  @override
  Future<DashboardResponse> getDashboardData(String patientId) async {
    try {
      final response = await _apiClient.get<Map<String, dynamic>>(
        '/patients/$patientId/dashboard',
      );
      return DashboardResponse.fromJson(response);
    } catch (e) {
      throw _handleApiError(e);
    }
  }

  @override
  Future<List<HealthEducationItem>> getEducationItems({
    int page = 1,
    int limit = 10,
  }) async {
    try {
      final response = await _apiClient.get<Map<String, dynamic>>(
        '/health-education',
        queryParameters: {
          'page': page,
          'limit': limit,
        },
      );

      final List<dynamic> items = response['items'] ?? [];
      return items
          .map((item) => HealthEducationItem.fromJson(item))
          .toList();
    } catch (e) {
      throw _handleApiError(e);
    }
  }

  @override
  Future<void> markEducationAsRead(String itemId) async {
    try {
      await _apiClient.post(
        '/health-education/$itemId/read',
      );
    } catch (e) {
      throw _handleApiError(e);
    }
  }

  AppError _handleApiError(dynamic error) {
    if (error is DioException) {
      switch (error.response?.statusCode) {
        case 404:
          return const AppError.network(message: '数据不存在');
        case 500:
          return const AppError.network(message: '服务器内部错误');
        default:
          return AppError.network(
            message: error.message ?? '网络请求失败',
            statusCode: error.response?.statusCode,
          );
      }
    }
    return AppError.unknown(message: error.toString(), cause: error);
  }
}

// Mock 远程数据源实现
class DashboardRemoteDataSourceMock implements DashboardRemoteDataSource {
  final Duration _delay;

  DashboardRemoteDataSourceMock({
    Duration delay = const Duration(milliseconds: 1000),
  }) : _delay = delay;

  @override
  Future<DashboardResponse> getDashboardData(String patientId) async {
    await Future.delayed(_delay);

    return DashboardResponse(
      healthData: HealthDataOverview(
        bloodPressure: BloodPressureSummary(
          systolic: 128,
          diastolic: 82,
          recordedAt: DateTime.now().subtract(const Duration(hours: 2)),
          level: BloodPressureLevel.elevated,
          trend: 'stable',
        ),
        heartRate: HeartRateSummary(
          bpm: 72,
          recordedAt: DateTime.now().subtract(const Duration(hours: 1)),
          zone: HeartRateZone.resting,
          trend: 'stable',
        ),
        weight: WeightSummary(
          weight: 68.5,
          recordedAt: DateTime.now().subtract(const Duration(days: 1)),
          bmi: 22.3,
          bmiCategory: BMICategory.normal,
          trend: 'falling',
        ),
        steps: StepsSummary(
          steps: 7832,
          date: DateTime.now(),
          goal: 10000,
          calories: 324.5,
          distance: 5.8,
        ),
        lastUpdated: DateTime.now(),
      ),
      recoveryGoals: [
        RecoveryGoal(
          id: 'goal_1',
          title: '血压控制目标',
          description: '维持血压在正常范围内',
          type: GoalType.blood_pressure,
          targetValue: 120,
          currentValue: 128,
          unit: 'mmHg',
          startDate: DateTime.now().subtract(const Duration(days: 30)),
          endDate: DateTime.now().add(const Duration(days: 60)),
          status: GoalStatus.active,
        ),
        RecoveryGoal(
          id: 'goal_2',
          title: '每日步数目标',
          description: '每天走路10000步',
          type: GoalType.exercise,
          targetValue: 10000,
          currentValue: 7832,
          unit: '步',
          startDate: DateTime.now().subtract(const Duration(days: 10)),
          endDate: DateTime.now().add(const Duration(days: 20)),
          status: GoalStatus.active,
        ),
      ],
      educationItems: [
        HealthEducationItem(
          id: 'edu_1',
          title: '高血压患者的饮食指南',
          summary: '合理的饮食习惯对控制血压至关重要',
          content: '详细的饮食指南内容...',
          type: EducationType.article,
          imageUrl: 'https://example.com/images/diet-guide.jpg',
          readingTime: 5,
          tags: ['饮食', '高血压', '健康'],
          publishedAt: DateTime.now().subtract(const Duration(days: 2)),
          isRead: false,
          isFavorited: false,
        ),
        HealthEducationItem(
          id: 'edu_2',
          title: '正确测量血压的方法',
          summary: '学会正确测量血压，获得准确的健康数据',
          content: '血压测量方法详解...',
          type: EducationType.video,
          videoUrl: 'https://example.com/videos/bp-measurement.mp4',
          readingTime: 8,
          tags: ['血压', '测量', '教程'],
          publishedAt: DateTime.now().subtract(const Duration(days: 5)),
          isRead: true,
          isFavorited: true,
        ),
      ],
      lastUpdated: DateTime.now(),
    );
  }

  @override
  Future<List<HealthEducationItem>> getEducationItems({
    int page = 1,
    int limit = 10,
  }) async {
    await Future.delayed(_delay);

    // 模拟分页数据
    final allItems = List.generate(25, (index) => HealthEducationItem(
      id: 'edu_${index + 1}',
      title: '健康教育文章 ${index + 1}',
      summary: '这是第 ${index + 1} 篇健康教育文章的摘要',
      content: '文章内容...',
      type: index % 3 == 0 ? EducationType.video : EducationType.article,
      readingTime: 3 + (index % 10),
      tags: ['健康', '教育'],
      publishedAt: DateTime.now().subtract(Duration(days: index)),
      isRead: index % 4 == 0,
      isFavorited: index % 7 == 0,
    ));

    final startIndex = (page - 1) * limit;
    final endIndex = math.min(startIndex + limit, allItems.length);

    if (startIndex >= allItems.length) {
      return [];
    }

    return allItems.sublist(startIndex, endIndex);
  }

  @override
  Future<void> markEducationAsRead(String itemId) async {
    await Future.delayed(const Duration(milliseconds: 200));
    // Mock 实现不需要实际操作
  }
}

// 本地数据源实现
class DashboardLocalDataSourceImpl implements DashboardLocalDataSource {
  final SharedPreferences _prefs;

  static const String _keyDashboardPrefix = 'dashboard_';
  static const String _keyReadEducation = 'read_education_ids';
  static const String _keyFavoritedEducation = 'favorited_education_ids';

  DashboardLocalDataSourceImpl(this._prefs);

  @override
  Future<DashboardResponse?> getCachedDashboard(String patientId) async {
    try {
      final key = '$_keyDashboardPrefix$patientId';
      final jsonString = _prefs.getString(key);

      if (jsonString != null) {
        final json = jsonDecode(jsonString) as Map<String, dynamic>;
        return DashboardResponse.fromJson(json);
      }

      return null;
    } catch (e) {
      Logger.error('Failed to get cached dashboard', e);
      return null;
    }
  }

  @override
  Future<void> cacheDashboard(String patientId, DashboardResponse data) async {
    try {
      final key = '$_keyDashboardPrefix$patientId';
      final jsonString = jsonEncode(data.toJson());
      await _prefs.setString(key, jsonString);
    } catch (e) {
      Logger.error('Failed to cache dashboard', e);
    }
  }

  @override
  Future<List<String>> getReadEducationIds() async {
    return _prefs.getStringList(_keyReadEducation) ?? [];
  }

  @override
  Future<void> markEducationAsRead(String itemId) async {
    final readIds = await getReadEducationIds();
    if (!readIds.contains(itemId)) {
      readIds.add(itemId);
      await _prefs.setStringList(_keyReadEducation, readIds);
    }
  }

  @override
  Future<List<String>> getFavoritedEducationIds() async {
    return _prefs.getStringList(_keyFavoritedEducation) ?? [];
  }

  @override
  Future<void> toggleEducationFavorite(String itemId, bool isFavorited) async {
    final favoritedIds = await getFavoritedEducationIds();

    if (isFavorited && !favoritedIds.contains(itemId)) {
      favoritedIds.add(itemId);
    } else if (!isFavorited) {
      favoritedIds.remove(itemId);
    }

    await _prefs.setStringList(_keyFavoritedEducation, favoritedIds);
  }
}
```

### 3.3 仓库实现

```dart
// 首页仓库接口
abstract class DashboardRepository {
  Future<Result<DashboardResponse, AppError>> getDashboardData(
    String patientId, {
    bool forceRefresh = false,
  });
  Future<Result<List<HealthEducationItem>, AppError>> getEducationItems({
    int page = 1,
    int limit = 10,
  });
  Future<Result<void, AppError>> markEducationAsRead(String itemId);
  Future<Result<void, AppError>> toggleEducationFavorite(
    String itemId,
    bool isFavorited,
  );
}

// 首页仓库实现
class DashboardRepositoryImpl implements DashboardRepository {
  final DashboardRemoteDataSource _remoteDataSource;
  final DashboardLocalDataSource _localDataSource;

  DashboardRepositoryImpl(this._remoteDataSource, this._localDataSource);

  @override
  Future<Result<DashboardResponse, AppError>> getDashboardData(
    String patientId, {
    bool forceRefresh = false,
  }) async {
    try {
      // 如果不强制刷新，先尝试获取缓存数据
      if (!forceRefresh) {
        final cachedData = await _localDataSource.getCachedDashboard(patientId);
        if (cachedData != null) {
          // 检查缓存是否过期（5分钟）
          final cacheAge = DateTime.now().difference(
            cachedData.lastUpdated ?? DateTime.fromMillisecondsSinceEpoch(0),
          );

          if (cacheAge.inMinutes < 5) {
            return Result.success(cachedData);
          }
        }
      }

      // 获取远程数据
      final remoteData = await _remoteDataSource.getDashboardData(patientId);

      // 合并本地阅读状态
      final updatedData = await _mergeLocalEducationStatus(remoteData);

      // 缓存数据
      await _localDataSource.cacheDashboard(patientId, updatedData);

      return Result.success(updatedData);
    } on AppError catch (e) {
      // 网络错误时，尝试返回缓存数据
      if (e is NetworkError) {
        final cachedData = await _localDataSource.getCachedDashboard(patientId);
        if (cachedData != null) {
          return Result.success(cachedData);
        }
      }
      return Result.failure(e);
    } catch (e) {
      return Result.failure(AppError.unknown(message: e.toString(), cause: e));
    }
  }

  @override
  Future<Result<void, AppError>> markEducationAsRead(String itemId) async {
    try {
      // 先更新本地状态
      await _localDataSource.markEducationAsRead(itemId);

      // 然后同步到服务器
      await _remoteDataSource.markEducationAsRead(itemId);

      return const Result.success(null);
    } on AppError catch (e) {
      return Result.failure(e);
    } catch (e) {
      return Result.failure(AppError.unknown(message: e.toString(), cause: e));
    }
  }

  @override
  Future<Result<void, AppError>> toggleEducationFavorite(
    String itemId,
    bool isFavorited,
  ) async {
    try {
      // 先更新本地状态
      await _localDataSource.toggleEducationFavorite(itemId, isFavorited);

      // 然后同步到服务器
      await _remoteDataSource.toggleEducationFavorite(itemId, isFavorited);

      return const Result.success(null);
    } on AppError catch (e) {
      return Result.failure(e);
    } catch (e) {
      return Result.failure(AppError.unknown(message: e.toString(), cause: e));
    }
  }

  Future<DashboardResponse> _mergeLocalEducationStatus(
    DashboardResponse remoteData,
  ) async {
    final readIds = await _localDataSource.getReadEducationIds();
    final favoritedIds = await _localDataSource.getFavoritedEducationIds();

    final updatedEducationItems = remoteData.educationItems.map((item) {
      return item.copyWith(
        isRead: readIds.contains(item.id),
        isFavorited: favoritedIds.contains(item.id),
      );
    }).toList();

    return remoteData.copyWith(educationItems: updatedEducationItems);
  }
}
```

## 4. 业务逻辑层 (Domain)

### 4.1 用例定义

```dart
// 获取首页数据用例
@riverpod
class GetDashboardDataUseCase extends _$GetDashboardDataUseCase {
  @override
  void build() {}

  Future<Result<DashboardResponse, AppError>> execute(
    String patientId, {
    bool forceRefresh = false,
  }) async {
    final repository = ref.read(dashboardRepositoryProvider);
    return await repository.getDashboardData(
      patientId,
      forceRefresh: forceRefresh,
    );
  }
}

// 标记教育内容为已读用例
@riverpod
class MarkEducationAsReadUseCase extends _$MarkEducationAsReadUseCase {
  @override
  void build() {}

  Future<Result<void, AppError>> execute(String itemId) async {
    final repository = ref.read(dashboardRepositoryProvider);
    return await repository.markEducationAsRead(itemId);
  }
}

// 切换教育内容收藏状态用例
@riverpod
class ToggleEducationFavoriteUseCase extends _$ToggleEducationFavoriteUseCase {
  @override
  void build() {}

  Future<Result<void, AppError>> execute(String itemId, bool isFavorited) async {
    final repository = ref.read(dashboardRepositoryProvider);
    return await repository.toggleEducationFavorite(itemId, isFavorited);
  }
}

// 计算健康评分用例
@riverpod
class CalculateHealthScoreUseCase extends _$CalculateHealthScoreUseCase {
  @override
  void build() {}

  int execute(HealthDataOverview healthData) {
    int score = 0;
    int totalMetrics = 0;

    // 血压评分 (25分)
    if (healthData.bloodPressure != null) {
      totalMetrics++;
      switch (healthData.bloodPressure!.level) {
        case BloodPressureLevel.normal:
          score += 25;
          break;
        case BloodPressureLevel.elevated:
          score += 20;
          break;
        case BloodPressureLevel.stage1:
          score += 15;
          break;
        case BloodPressureLevel.stage2:
          score += 10;
          break;
        case BloodPressureLevel.crisis:
          score += 5;
          break;
        case null:
          break;
      }
    }

    // 心率评分 (25分)
    if (healthData.heartRate != null) {
      totalMetrics++;
      final bpm = healthData.heartRate!.bpm;
      if (bpm >= 60 && bpm <= 80) {
        score += 25;
      } else if (bpm >= 50 && bpm <= 90) {
        score += 20;
      } else if (bpm >= 40 && bpm <= 100) {
        score += 15;
      } else {
        score += 10;
      }
    }

    // BMI 评分 (25分)
    if (healthData.weight?.bmi != null) {
      totalMetrics++;
      switch (healthData.weight!.bmiCategory) {
        case BMICategory.normal:
          score += 25;
          break;
        case BMICategory.overweight:
        case BMICategory.underweight:
          score += 20;
          break;
        case BMICategory.obese:
          score += 15;
          break;
        case null:
          break;
      }
    }

    // 步数评分 (25分)
    if (healthData.steps != null) {
      totalMetrics++;
      final progress = healthData.steps!.goalProgress;
      if (progress >= 1.0) {
        score += 25;
      } else if (progress >= 0.8) {
        score += 20;
      } else if (progress >= 0.6) {
        score += 15;
      } else if (progress >= 0.4) {
        score += 10;
      } else {
        score += 5;
      }
    }

    // 计算平均分
    if (totalMetrics == 0) return 0;
    return (score / totalMetrics * 4).round(); // 转换为100分制
  }
}
```

## 5. 表现层架构

### 5.1 状态管理 Providers

```dart
// 首页状态管理
@riverpod
class DashboardNotifier extends _$DashboardNotifier {
  @override
  AsyncValue<DashboardState> build() {
    _loadInitialData();
    return const AsyncValue.loading();
  }

  Future<void> refresh() async {
    if (state.isLoading) return;

    final currentUser = ref.read(currentUserProvider);
    if (currentUser == null) {
      state = const AsyncValue.error(
        AppError.authentication(message: '用户未登录'),
        StackTrace.empty,
      );
      return;
    }

    // 获取当前患者
    final patients = ref.read(currentPatientsProvider);
    if (patients.isEmpty) {
      state = const AsyncValue.data(DashboardState(
        error: '请先添加就诊人信息',
      ));
      return;
    }

    final patientId = patients.first.id;

    // 设置刷新状态
    state.whenData((currentState) {
      state = AsyncValue.data(currentState.copyWith(isRefreshing: true));
    });

    final useCase = ref.read(getDashboardDataUseCaseProvider.notifier);
    final result = await useCase.execute(patientId, forceRefresh: true);

    result.when(
      success: (response) {
        state = AsyncValue.data(DashboardState(
          healthData: response.healthData,
          recoveryGoals: response.recoveryGoals,
          educationItems: response.educationItems,
          lastUpdated: response.lastUpdated,
        ));
      },
      failure: (error) {
        state.whenData((currentState) {
          state = AsyncValue.data(currentState.copyWith(
            isRefreshing: false,
            error: error.toString(),
          ));
        });
      },
    );
  }

  Future<void> markEducationAsRead(String itemId) async {
    final useCase = ref.read(markEducationAsReadUseCaseProvider.notifier);
    final result = await useCase.execute(itemId);

    result.when(
      success: (_) {
        // 更新本地状态
        state.whenData((currentState) {
          final updatedItems = currentState.educationItems.map((item) {
            if (item.id == itemId) {
              return item.copyWith(isRead: true);
            }
            return item;
          }).toList();

          state = AsyncValue.data(currentState.copyWith(
            educationItems: updatedItems,
          ));
        });
      },
      failure: (error) {
        // 显示错误但不影响当前状态
        Logger.error('Failed to mark education as read', error);
      },
    );
  }

  Future<void> toggleEducationFavorite(String itemId) async {
    // 先乐观更新 UI
    late bool newFavoriteStatus;
    state.whenData((currentState) {
      final item = currentState.educationItems.firstWhere(
        (item) => item.id == itemId,
      );
      newFavoriteStatus = !item.isFavorited;

      final updatedItems = currentState.educationItems.map((item) {
        if (item.id == itemId) {
          return item.copyWith(isFavorited: newFavoriteStatus);
        }
        return item;
      }).toList();

      state = AsyncValue.data(currentState.copyWith(
        educationItems: updatedItems,
      ));
    });

    // 然后同步到服务器
    final useCase = ref.read(toggleEducationFavoriteUseCaseProvider.notifier);
    final result = await useCase.execute(itemId, newFavoriteStatus);

    result.when(
      success: (_) {
        // 服务器更新成功，无需额外操作
      },
      failure: (error) {
        // 服务器更新失败，回滚 UI 状态
        state.whenData((currentState) {
          final updatedItems = currentState.educationItems.map((item) {
            if (item.id == itemId) {
              return item.copyWith(isFavorited: !newFavoriteStatus);
            }
            return item;
          }).toList();

          state = AsyncValue.data(currentState.copyWith(
            educationItems: updatedItems,
          ));
        });

        Logger.error('Failed to toggle education favorite', error);
      },
    );
  }

  Future<void> _loadInitialData() async {
    final currentUser = ref.read(currentUserProvider);
    if (currentUser == null) {
      state = const AsyncValue.error(
        AppError.authentication(message: '用户未登录'),
        StackTrace.empty,
      );
      return;
    }

    final patients = ref.read(currentPatientsProvider);
    if (patients.isEmpty) {
      state = const AsyncValue.data(DashboardState(
        error: '请先添加就诊人信息',
      ));
      return;
    }

    final patientId = patients.first.id;
    final useCase = ref.read(getDashboardDataUseCaseProvider.notifier);
    final result = await useCase.execute(patientId);

    result.when(
      success: (response) {
        state = AsyncValue.data(DashboardState(
          healthData: response.healthData,
          recoveryGoals: response.recoveryGoals,
          educationItems: response.educationItems,
          lastUpdated: response.lastUpdated,
        ));
      },
      failure: (error) {
        state = AsyncValue.error(error, StackTrace.current);
      },
    );
  }
}

// 健康评分计算
@riverpod
int healthScore(HealthScoreRef ref) {
  final dashboardState = ref.watch(dashboardNotifierProvider);

  return dashboardState.maybeWhen(
    data: (state) {
      if (state.healthData == null) return 0;

      final useCase = ref.read(calculateHealthScoreUseCaseProvider.notifier);
      return useCase.execute(state.healthData!);
    },
    orElse: () => 0,
  );
}

// 便利的派生状态
@riverpod
List<RecoveryGoal> urgentGoals(UrgentGoalsRef ref) {
  return ref.watch(dashboardNotifierProvider).maybeWhen(
    data: (state) => state.activeGoals
        .where((goal) => goal.daysRemaining <= 7 && !goal.isCompleted)
        .toList(),
    orElse: () => [],
  );
}

@riverpod
List<HealthEducationItem> recommendedEducation(RecommendedEducationRef ref) {
  return ref.watch(dashboardNotifierProvider).maybeWhen(
    data: (state) => state.educationItems
        .where((item) => !item.isRead)
        .take(3)
        .toList(),
    orElse: () => [],
  );
}
```

### 5.2 UI 组件设计

```dart
// 首页主屏幕
class DashboardScreen extends ConsumerWidget {
  const DashboardScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final dashboardState = ref.watch(dashboardNotifierProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('健康首页'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () => ref.read(dashboardNotifierProvider.notifier).refresh(),
          ),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: () => ref.read(dashboardNotifierProvider.notifier).refresh(),
        child: dashboardState.when(
          loading: () => const _LoadingView(),
          error: (error, stackTrace) => _ErrorView(
            error: error,
            onRetry: () => ref.read(dashboardNotifierProvider.notifier).refresh(),
          ),
          data: (state) => _DashboardContent(state: state),
        ),
      ),
    );
  }
}

// 首页内容组件
class _DashboardContent extends ConsumerWidget {
  const _DashboardContent({required this.state});

  final DashboardState state;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    if (state.isEmpty) {
      return const _EmptyStateView();
    }

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        // 健康评分卡片
        _HealthScoreCard(),

        const SizedBox(height: 16),

        // 健康数据概览
        if (state.healthData != null) ...[
          _HealthDataOverviewSection(data: state.healthData!),
          const SizedBox(height: 16),
        ],

        // 康复目标
        if (state.activeGoals.isNotEmpty) ...[
          _RecoveryGoalsSection(goals: state.activeGoals),
          const SizedBox(height: 16),
        ],

        // 健康宣教
        if (state.educationItems.isNotEmpty) ...[
          _HealthEducationSection(items: state.educationItems),
          const SizedBox(height: 16),
        ],

        // 快速操作
        const _QuickActionsSection(),
      ],
    );
  }
}

// 健康评分卡片
class _HealthScoreCard extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final score = ref.watch(healthScoreProvider);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          children: [
            Text(
              '健康评分',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 16),
            _CircularScoreIndicator(score: score),
            const SizedBox(height: 12),
            Text(
              _getScoreDescription(score),
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _getScoreDescription(int score) {
    if (score >= 90) return '健康状况优秀';
    if (score >= 80) return '健康状况良好';
    if (score >= 70) return '健康状况一般';
    if (score >= 60) return '需要关注健康';
    return '建议咨询医生';
  }
}

// 健康数据概览区域
class _HealthDataOverviewSection extends StatelessWidget {
  const _HealthDataOverviewSection({required this.data});

  final HealthDataOverview data;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '健康数据',
          style: Theme.of(context).textTheme.titleLarge,
        ),
        const SizedBox(height: 12),
        GridView.count(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          crossAxisCount: 2,
          mainAxisSpacing: 12,
          crossAxisSpacing: 12,
          childAspectRatio: 1.2,
          children: [
            if (data.bloodPressure != null)
              _BloodPressureCard(data: data.bloodPressure!),
            if (data.heartRate != null)
              _HeartRateCard(data: data.heartRate!),
            if (data.weight != null)
              _WeightCard(data: data.weight!),
            if (data.steps != null)
              _StepsCard(data: data.steps!),
          ],
        ),
      ],
    );
  }
}

// 血压卡片
class _BloodPressureCard extends StatelessWidget {
  const _BloodPressureCard({required this.data});

  final BloodPressureSummary data;

  @override
  Widget build(BuildContext context) {
    return Card(
      child: InkWell(
        onTap: () => context.go('/health-data/blood-pressure'),
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(
                    Icons.favorite,
                    color: data.level?.color,
                    size: 20,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    '血压',
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                ],
              ),
              const Spacer(),
              Text(
                '${data.systolic}/${data.diastolic}',
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                  color: data.level?.color,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                'mmHg · ${data.level?.label ?? ''}',
                style: Theme.of(context).textTheme.bodySmall,
              ),
              Text(
                _formatRelativeTime(data.recordedAt),
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatRelativeTime(DateTime dateTime) {
    final duration = DateTime.now().difference(dateTime);
    if (duration.inDays > 0) {
      return '${duration.inDays}天前';
    } else if (duration.inHours > 0) {
      return '${duration.inHours}小时前';
    } else {
      return '${duration.inMinutes}分钟前';
    }
  }
}

// 康复目标区域
class _RecoveryGoalsSection extends ConsumerWidget {
  const _RecoveryGoalsSection({required this.goals});

  final List<RecoveryGoal> goals;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              '康复目标',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            TextButton(
              onPressed: () => context.go('/health-data/goals'),
              child: const Text('查看全部'),
            ),
          ],
        ),
        const SizedBox(height: 12),
        ...goals.take(3).map((goal) => Padding(
          padding: const EdgeInsets.only(bottom: 8),
          child: _RecoveryGoalCard(goal: goal),
        )),
      ],
    );
  }
}

// 康复目标卡片
class _RecoveryGoalCard extends StatelessWidget {
  const _RecoveryGoalCard({required this.goal});

  final RecoveryGoal goal;

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  goal.type.icon,
                  color: goal.type.color,
                  size: 20,
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    goal.title,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                ),
                if (goal.isCompleted)
                  const Icon(
                    Icons.check_circle,
                    color: Colors.green,
                    size: 20,
                  ),
              ],
            ),
            const SizedBox(height: 12),
            LinearProgressIndicator(
              value: goal.progress.clamp(0.0, 1.0),
              backgroundColor: goal.type.color.withOpacity(0.2),
              valueColor: AlwaysStoppedAnimation(goal.type.color),
            ),
            const SizedBox(height: 8),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  '${goal.currentValue.toStringAsFixed(0)} / ${goal.targetValue.toStringAsFixed(0)} ${goal.unit}',
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
                Text(
                  '剩余${goal.daysRemaining}天',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

// 健康宣教区域
class _HealthEducationSection extends ConsumerWidget {
  const _HealthEducationSection({required this.items});

  final List<HealthEducationItem> items;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              '健康宣教',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            TextButton(
              onPressed: () => context.go('/education'),
              child: const Text('查看全部'),
            ),
          ],
        ),
        const SizedBox(height: 12),
        ...items.take(3).map((item) => Padding(
          padding: const EdgeInsets.only(bottom: 8),
          child: _HealthEducationCard(item: item),
        )),
      ],
    );
  }
}

// 健康教育卡片
class _HealthEducationCard extends ConsumerWidget {
  const _HealthEducationCard({required this.item});

  final HealthEducationItem item;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      child: InkWell(
        onTap: () {
          // 标记为已读
          if (!item.isRead) {
            ref.read(dashboardNotifierProvider.notifier)
                .markEducationAsRead(item.id);
          }

          // 跳转到详情页
          context.go('/education/${item.id}');
        },
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // 类型图标
              Container(
                width: 40,
                height: 40,
                decoration: BoxDecoration(
                  color: Theme.of(context).primaryColor.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(
                  item.type.icon,
                  color: Theme.of(context).primaryColor,
                  size: 20,
                ),
              ),

              const SizedBox(width: 12),

              // 内容
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      item.title,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: item.isRead ? FontWeight.normal : FontWeight.bold,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      item.summary,
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        Icon(
                          Icons.access_time,
                          size: 12,
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          '${item.readingTime}分钟阅读',
                          style: Theme.of(context).textTheme.bodySmall?.copyWith(
                            color: Theme.of(context).colorScheme.onSurfaceVariant,
                          ),
                        ),
                        const Spacer(),
                        if (!item.isRead)
                          Container(
                            width: 8,
                            height: 8,
                            decoration: BoxDecoration(
                              color: Theme.of(context).primaryColor,
                              shape: BoxShape.circle,
                            ),
                          ),
                      ],
                    ),
                  ],
                ),
              ),

              // 收藏按钮
              IconButton(
                icon: Icon(
                  item.isFavorited ? Icons.favorite : Icons.favorite_border,
                  color: item.isFavorited ? Colors.red : null,
                ),
                onPressed: () => ref
                    .read(dashboardNotifierProvider.notifier)
                    .toggleEducationFavorite(item.id),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

## 6. TDD 测试策略

### 6.1 测试结构

```
test/features/dashboard/
├── data/
│   ├── datasources/
│   │   ├── dashboard_remote_datasource_test.dart
│   │   └── dashboard_local_datasource_test.dart
│   └── repositories/
│       └── dashboard_repository_test.dart
├── domain/
│   └── usecases/
│       ├── get_dashboard_data_usecase_test.dart
│       ├── mark_education_as_read_usecase_test.dart
│       └── calculate_health_score_usecase_test.dart
└── presentation/
    ├── providers/
    │   └── dashboard_notifier_test.dart
    └── screens/
        └── dashboard_screen_test.dart
```

### 6.2 核心测试用例

```dart
// 首页数据获取用例测试
void main() {
  group('GetDashboardDataUseCase', () {
    late ProviderContainer container;
    late MockDashboardRepository mockRepository;

    setUp(() {
      mockRepository = MockDashboardRepository();
      container = ProviderContainer(
        overrides: [
          dashboardRepositoryProvider.overrideWithValue(mockRepository),
        ],
      );
    });

    test('should return cached data when available and not expired', () async {
      // Given
      const patientId = 'patient_1';
      final cachedResponse = DashboardResponse(
        healthData: HealthDataOverview(
          bloodPressure: BloodPressureSummary(
            systolic: 120,
            diastolic: 80,
            recordedAt: DateTime.now(),
            level: BloodPressureLevel.normal,
          ),
        ),
        recoveryGoals: [],
        educationItems: [],
        lastUpdated: DateTime.now().subtract(const Duration(minutes: 2)),
      );

      when(() => mockRepository.getDashboardData(patientId, forceRefresh: false))
          .thenAnswer((_) async => Result.success(cachedResponse));

      // When
      final useCase = container.read(getDashboardDataUseCaseProvider.notifier);
      final result = await useCase.execute(patientId);

      // Then
      expect(result.isSuccess, true);
      result.when(
        success: (response) {
          expect(response.healthData?.bloodPressure?.systolic, 120);
          expect(response.lastUpdated, isNotNull);
        },
        failure: (_) => fail('Expected success'),
      );
    });

    test('should force refresh when requested', () async {
      // Given
      const patientId = 'patient_1';
      final freshResponse = DashboardResponse(
        healthData: HealthDataOverview(),
        recoveryGoals: [],
        educationItems: [],
        lastUpdated: DateTime.now(),
      );

      when(() => mockRepository.getDashboardData(patientId, forceRefresh: true))
          .thenAnswer((_) async => Result.success(freshResponse));

      // When
      final useCase = container.read(getDashboardDataUseCaseProvider.notifier);
      final result = await useCase.execute(patientId, forceRefresh: true);

      // Then
      expect(result.isSuccess, true);
      verify(() => mockRepository.getDashboardData(patientId, forceRefresh: true))
          .called(1);
    });
  });
}

// 健康评分计算测试
void main() {
  group('CalculateHealthScoreUseCase', () {
    late ProviderContainer container;

    setUp(() {
      container = ProviderContainer();
    });

    test('should return perfect score for optimal health data', () {
      // Given
      final healthData = HealthDataOverview(
        bloodPressure: BloodPressureSummary(
          systolic: 120,
          diastolic: 80,
          recordedAt: DateTime.now(),
          level: BloodPressureLevel.normal,
        ),
        heartRate: HeartRateSummary(
          bpm: 70,
          recordedAt: DateTime.now(),
          zone: HeartRateZone.resting,
        ),
        weight: WeightSummary(
          weight: 70.0,
          recordedAt: DateTime.now(),
          bmi: 22.0,
          bmiCategory: BMICategory.normal,
        ),
        steps: StepsSummary(
          steps: 10000,
          date: DateTime.now(),
          goal: 10000,
        ),
      );

      // When
      final useCase = container.read(calculateHealthScoreUseCaseProvider.notifier);
      final score = useCase.execute(healthData);

      // Then
      expect(score, 100);
    });

    test('should return lower score for suboptimal health data', () {
      // Given
      final healthData = HealthDataOverview(
        bloodPressure: BloodPressureSummary(
          systolic: 140,
          diastolic: 90,
          recordedAt: DateTime.now(),
          level: BloodPressureLevel.stage1,
        ),
        heartRate: HeartRateSummary(
          bpm: 100,
          recordedAt: DateTime.now(),
          zone: HeartRateZone.cardio,
        ),
        weight: WeightSummary(
          weight: 85.0,
          recordedAt: DateTime.now(),
          bmi: 28.0,
          bmiCategory: BMICategory.overweight,
        ),
        steps: StepsSummary(
          steps: 5000,
          date: DateTime.now(),
          goal: 10000,
        ),
      );

      // When
      final useCase = container.read(calculateHealthScoreUseCaseProvider.notifier);
      final score = useCase.execute(healthData);

      // Then
      expect(score, lessThan(80));
      expect(score, greaterThan(40));
    });

    test('should return 0 when no health data available', () {
      // Given
      const healthData = HealthDataOverview();

      // When
      final useCase = container.read(calculateHealthScoreUseCaseProvider.notifier);
      final score = useCase.execute(healthData);

      // Then
      expect(score, 0);
    });
  });
}

// 首页状态管理测试
void main() {
  group('DashboardNotifier', () {
    late ProviderContainer container;
    late MockGetDashboardDataUseCase mockUseCase;
    late MockUser mockUser;
    late MockPatient mockPatient;

    setUp(() {
      mockUseCase = MockGetDashboardDataUseCase();
      mockUser = MockUser();
      mockPatient = MockPatient();

      when(() => mockUser.id).thenReturn('user_1');
      when(() => mockPatient.id).thenReturn('patient_1');

      container = ProviderContainer(
        overrides: [
          getDashboardDataUseCaseProvider.overrideWith(() => mockUseCase),
          currentUserProvider.overrideWith((ref) => mockUser),
          currentPatientsProvider.overrideWith((ref) => [mockPatient]),
        ],
      );
    });

    test('should load dashboard data on initialization', () async {
      // Given
      final dashboardResponse = DashboardResponse(
        healthData: HealthDataOverview(),
        recoveryGoals: [],
        educationItems: [],
        lastUpdated: DateTime.now(),
      );

      when(() => mockUseCase.execute('patient_1'))
          .thenAnswer((_) async => Result.success(dashboardResponse));

      // When
      final notifier = container.read(dashboardNotifierProvider.notifier);

      // Wait for async initialization
      await container.read(dashboardNotifierProvider.future);

      // Then
      final state = container.read(dashboardNotifierProvider);
      expect(state.hasValue, true);

      state.whenData((dashboardState) {
        expect(dashboardState.healthData, isNotNull);
        expect(dashboardState.isLoading, false);
        expect(dashboardState.hasError, false);
      });

      verify(() => mockUseCase.execute('patient_1')).called(1);
    });

    test('should handle refresh correctly', () async {
      // Given
      final initialResponse = DashboardResponse(
        healthData: HealthDataOverview(),
        recoveryGoals: [],
        educationItems: [],
        lastUpdated: DateTime.now().subtract(const Duration(hours: 1)),
      );

      final refreshedResponse = DashboardResponse(
        healthData: HealthDataOverview(),
        recoveryGoals: [],
        educationItems: [],
        lastUpdated: DateTime.now(),
      );

      when(() => mockUseCase.execute('patient_1'))
          .thenAnswer((_) async => Result.success(initialResponse));

      when(() => mockUseCase.execute('patient_1', forceRefresh: true))
          .thenAnswer((_) async => Result.success(refreshedResponse));

      // When
      final notifier = container.read(dashboardNotifierProvider.notifier);
      await container.read(dashboardNotifierProvider.future);

      await notifier.refresh();

      // Then
      final state = container.read(dashboardNotifierProvider);
      state.whenData((dashboardState) {
        expect(dashboardState.isRefreshing, false);
        expect(dashboardState.lastUpdated, refreshedResponse.lastUpdated);
      });

      verify(() => mockUseCase.execute('patient_1', forceRefresh: true)).called(1);
    });

    test('should update education read status optimistically', () async {
      // Given
      const itemId = 'edu_1';
      final educationItem = HealthEducationItem(
        id: itemId,
        title: 'Test Article',
        summary: 'Test summary',
        content: 'Test content',
        type: EducationType.article,
        readingTime: 5,
        publishedAt: DateTime.now(),
        isRead: false,
        isFavorited: false,
      );

      final dashboardResponse = DashboardResponse(
        healthData: HealthDataOverview(),
        recoveryGoals: [],
        educationItems: [educationItem],
        lastUpdated: DateTime.now(),
      );

      when(() => mockUseCase.execute('patient_1'))
          .thenAnswer((_) async => Result.success(dashboardResponse));

      // When
      final notifier = container.read(dashboardNotifierProvider.notifier);
      await container.read(dashboardNotifierProvider.future);

      await notifier.markEducationAsRead(itemId);

      // Then
      final state = container.read(dashboardNotifierProvider);
      state.whenData((dashboardState) {
        final item = dashboardState.educationItems.firstWhere(
          (item) => item.id == itemId,
        );
        expect(item.isRead, true);
      });
    });
  });
}

// UI 组件测试
void main() {
  group('DashboardScreen', () {
    testWidgets('should show loading indicator when loading', (tester) async {
      // Given
      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            dashboardNotifierProvider.overrideWith(
              (ref) => MockDashboardNotifier()..setLoading(),
            ),
          ],
          child: const MaterialApp(home: DashboardScreen()),
        ),
      );

      // Then
      expect(find.byType(CircularProgressIndicator), findsOneWidget);
    });

    testWidgets('should show error message when error occurs', (tester) async {
      // Given
      const error = AppError.network(message: 'Network error');

      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            dashboardNotifierProvider.overrideWith(
              (ref) => MockDashboardNotifier()..setError(error),
            ),
          ],
          child: const MaterialApp(home: DashboardScreen()),
        ),
      );

      // Then
      expect(find.text('Network error'), findsOneWidget);
      expect(find.text('重试'), findsOneWidget);
    });

    testWidgets('should show dashboard content when data loaded', (tester) async {
      // Given
      final dashboardState = DashboardState(
        healthData: HealthDataOverview(
          bloodPressure: BloodPressureSummary(
            systolic: 120,
            diastolic: 80,
            recordedAt: DateTime.now(),
            level: BloodPressureLevel.normal,
          ),
        ),
        recoveryGoals: [
          RecoveryGoal(
            id: 'goal_1',
            title: '血压控制',
            description: '控制血压在正常范围',
            type: GoalType.blood_pressure,
            targetValue: 120,
            currentValue: 120,
            unit: 'mmHg',
            startDate: DateTime.now(),
            endDate: DateTime.now().add(const Duration(days: 30)),
          ),
        ],
        educationItems: [
          HealthEducationItem(
            id: 'edu_1',
            title: '健康教育文章',
            summary: '文章摘要',
            content: '文章内容',
            type: EducationType.article,
            readingTime: 5,
            publishedAt: DateTime.now(),
            isRead: false,
            isFavorited: false,
          ),
        ],
      );

      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            dashboardNotifierProvider.overrideWith(
              (ref) => MockDashboardNotifier()..setData(dashboardState),
            ),
            healthScoreProvider.overrideWith((ref) => 85),
          ],
          child: const MaterialApp(home: DashboardScreen()),
        ),
      );

      // Then
      expect(find.text('健康评分'), findsOneWidget);
      expect(find.text('健康数据'), findsOneWidget);
      expect(find.text('康复目标'), findsOneWidget);
      expect(find.text('健康宣教'), findsOneWidget);
      expect(find.text('120/80'), findsOneWidget);
      expect(find.text('血压控制'), findsOneWidget);
      expect(find.text('健康教育文章'), findsOneWidget);
    });
  });
}
```

## 7. 性能优化

### 7.1 数据缓存策略

```dart
// 分级缓存策略
class DashboardCacheManager {
  static const Duration shortCacheDuration = Duration(minutes: 5);
  static const Duration longCacheDuration = Duration(hours: 1);

  // L1 缓存：内存缓存（最新数据）
  static final Map<String, CachedData<DashboardResponse>> _memoryCache = {};

  // L2 缓存：本地存储（持久化）
  static late SharedPreferences _prefs;

  static Future<void> initialize(SharedPreferences prefs) async {
    _prefs = prefs;
  }

  static Future<DashboardResponse?> getCachedData(String patientId) async {
    // 先查内存缓存
    final memoryData = _memoryCache[patientId];
    if (memoryData != null && !memoryData.isExpired(shortCacheDuration)) {
      return memoryData.data;
    }

    // 再查本地缓存
    final localData = await _getLocalCachedData(patientId);
    if (localData != null && !localData.isExpired(longCacheDuration)) {
      // 将本地数据加载到内存
      _memoryCache[patientId] = localData;
      return localData.data;
    }

    return null;
  }

  static Future<void> cacheData(String patientId, DashboardResponse data) async {
    final cachedData = CachedData(data, DateTime.now());

    // 更新内存缓存
    _memoryCache[patientId] = cachedData;

    // 更新本地缓存
    await _saveLocalCachedData(patientId, cachedData);
  }
}
```

### 7.2 组件优化

```dart
// 使用 memo 优化列表渲染
class OptimizedEducationList extends ConsumerWidget {
  const OptimizedEducationList({super.key, required this.items});

  final List<HealthEducationItem> items;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListView.builder(
      itemCount: items.length,
      itemBuilder: (context, index) {
        final item = items[index];

        // 使用 key 优化重建
        return EducationItemCard(
          key: ValueKey(item.id),
          item: item,
        );
      },
    );
  }
}

// 使用 const 构造函数优化静态组件
class ConstOptimizedCard extends StatelessWidget {
  const ConstOptimizedCard({
    super.key,
    required this.title,
    required this.value,
    required this.color,
  });

  final String title;
  final String value;
  final Color color;

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0), // const
        child: Column(
          children: [
            Text(title, style: const TextStyle(fontSize: 16)), // const
            const SizedBox(height: 8), // const
            Text(
              value,
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: color,
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

这个首页模块架构设计完整覆盖了需求中的所有功能点，提供了完整的 TDD 测试策略和性能优化方案，开发者可以基于此文档进行独立开发。
