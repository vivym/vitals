# 用户认证模块架构设计

## 1. 模块概述

### 1.1 功能描述
用户认证模块负责处理用户登录、会话管理、自动登录等核心认证功能，确保应用的安全性和用户体验。

### 1.2 核心功能
- **一键登录**: 模拟登录流程，无需真实手机验证
- **自动登录**: 应用启动时检查本地token，自动恢复登录状态
- **会话管理**: 管理用户登录状态和token生命周期
- **协议同意**: 处理服务协议和隐私协议的同意逻辑
- **患者管理**: 添加和管理签约患者信息
- **全局认证**: 提供全局认证状态和拦截机制

### 1.3 技术要求
- 严格遵循 TDD 开发模式
- 支持 Mock 和真实 API 切换
- 基于 Riverpod + Freezed 架构
- 安全的本地存储（token 加密）

## 2. 数据模型设计

### 2.1 核心实体模型

```dart
// 用户实体
@freezed
class User with _$User {
  const factory User({
    required String id,
    required String name,
    required String phone,
    String? email,
    @JsonKey(name: 'avatar_url') String? avatarUrl,
    @JsonKey(name: 'created_at') DateTime? createdAt,
    @JsonKey(name: 'updated_at') DateTime? updatedAt,
  }) = _User;

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}

// 患者实体
@freezed
class Patient with _$Patient {
  const factory Patient({
    required String id,
    required String name,
    required String idNumber,
    required Gender gender,
    required DateTime birthDate,
    required String phone,
    String? medicalRecordNumber,
    String? emergencyContact,
    String? emergencyContactPhone,
    @JsonKey(name: 'created_at') DateTime? createdAt,
    @JsonKey(name: 'updated_at') DateTime? updatedAt,
  }) = _Patient;

  factory Patient.fromJson(Map<String, dynamic> json) => _$PatientFromJson(json);
}

// 性别枚举
@JsonEnum(valueField: 'value')
enum Gender {
  male(1, '男'),
  female(2, '女'),
  other(3, '其他');

  const Gender(this.value, this.label);
  final int value;
  final String label;
}

// 认证状态
@freezed
class AuthState with _$AuthState {
  const factory AuthState({
    User? user,
    List<Patient>? patients,
    String? token,
    @Default(false) bool isAuthenticated,
    @Default(false) bool isLoading,
    @Default(false) bool hasAgreedToTerms,
    String? error,
  }) = _AuthState;

  const AuthState._();

  bool get hasError => error != null;
  bool get isReady => !isLoading && error == null;
  bool get canLogin => hasAgreedToTerms && isReady;
}

// 登录请求/响应模型
@freezed
class LoginRequest with _$LoginRequest {
  const factory LoginRequest({
    required String phone,
    @Default(true) bool agreedToTerms,
  }) = _LoginRequest;

  factory LoginRequest.fromJson(Map<String, dynamic> json) => _$LoginRequestFromJson(json);
}

@freezed
class LoginResponse with _$LoginResponse {
  const factory LoginResponse({
    required String token,
    required User user,
    @Default([]) List<Patient> patients,
    @JsonKey(name: 'expires_at') DateTime? expiresAt,
  }) = _LoginResponse;

  factory LoginResponse.fromJson(Map<String, dynamic> json) => _$LoginResponseFromJson(json);
}

// 患者创建请求
@freezed
class CreatePatientRequest with _$CreatePatientRequest {
  const factory CreatePatientRequest({
    required String name,
    required String idNumber,
    required Gender gender,
    required DateTime birthDate,
    required String phone,
    String? medicalRecordNumber,
    String? emergencyContact,
    String? emergencyContactPhone,
  }) = _CreatePatientRequest;

  factory CreatePatientRequest.fromJson(Map<String, dynamic> json) =>
      _$CreatePatientRequestFromJson(json);
}
```

### 2.2 表单验证模型

```dart
// 表单验证状态
@freezed
class FormValidationState with _$FormValidationState {
  const factory FormValidationState({
    @Default({}) Map<String, String> errors,
    @Default(false) bool isValid,
  }) = _FormValidationState;
}

// 患者表单状态
@freezed
class PatientFormState with _$PatientFormState {
  const factory PatientFormState({
    String? name,
    String? idNumber,
    Gender? gender,
    DateTime? birthDate,
    String? phone,
    String? medicalRecordNumber,
    String? emergencyContact,
    String? emergencyContactPhone,
    @Default(FormValidationState()) FormValidationState validation,
    @Default(false) bool isSubmitting,
  }) = _PatientFormState;
}
```

## 3. 数据层架构

### 3.1 数据源接口

```dart
// 认证远程数据源接口
abstract class AuthRemoteDataSource {
  Future<LoginResponse> login(LoginRequest request);
  Future<void> logout();
  Future<User> getCurrentUser();
  Future<List<Patient>> getPatients();
  Future<Patient> createPatient(CreatePatientRequest request);
}

// 认证本地数据源接口
abstract class AuthLocalDataSource {
  Future<String?> getAuthToken();
  Future<void> saveAuthToken(String token);
  Future<void> removeAuthToken();
  Future<User?> getCachedUser();
  Future<void> saveCachedUser(User user);
  Future<void> removeCachedUser();
  Future<bool> hasAgreedToTerms();
  Future<void> saveTermsAgreement(bool agreed);
}
```

### 3.2 数据源实现

```dart
// Dio 远程数据源实现
class AuthRemoteDataSourceImpl implements AuthRemoteDataSource {
  final ApiClient _apiClient;

  AuthRemoteDataSourceImpl(this._apiClient);

  @override
  Future<LoginResponse> login(LoginRequest request) async {
    try {
      final response = await _apiClient.post<Map<String, dynamic>>(
        '/auth/mock-login',
        data: request.toJson(),
      );
      return LoginResponse.fromJson(response);
    } catch (e) {
      throw _handleApiError(e);
    }
  }

  @override
  Future<void> logout() async {
    try {
      await _apiClient.post('/auth/logout');
    } catch (e) {
      // 登出错误不阻断流程，仅记录日志
      Logger.warning('Logout API failed', e);
    }
  }

  AppError _handleApiError(dynamic error) {
    if (error is DioException) {
      switch (error.response?.statusCode) {
        case 401:
          return const AppError.authentication(message: '认证失败，请重新登录');
        case 422:
          return const AppError.validation(
            field: 'phone',
            message: '手机号格式不正确',
          );
        default:
          return AppError.network(
            message: error.message ?? '网络请求失败',
            statusCode: error.response?.statusCode,
          );
      }
    }
    return AppError.unknown(message: error.toString(), cause: error);
  }
}

// Mock 远程数据源实现
class AuthRemoteDataSourceMock implements AuthRemoteDataSource {
  final Duration _delay;

  AuthRemoteDataSourceMock({Duration delay = const Duration(milliseconds: 800)})
      : _delay = delay;

  @override
  Future<LoginResponse> login(LoginRequest request) async {
    await Future.delayed(_delay);

    // 模拟不同手机号的不同响应
    if (request.phone == '13800000000') {
      return LoginResponse(
        token: 'mock_token_${DateTime.now().millisecondsSinceEpoch}',
        user: const User(
          id: 'user_1',
          name: '张三',
          phone: '13800000000',
          email: 'zhangsan@example.com',
        ),
        patients: [
          Patient(
            id: 'patient_1',
            name: '张三',
            idNumber: '310101199001011234',
            gender: Gender.male,
            birthDate: DateTime(1990, 1, 1),
            phone: '13800000000',
          ),
        ],
        expiresAt: DateTime.now().add(const Duration(days: 30)),
      );
    } else if (request.phone == '13900000000') {
      // 模拟无患者的用户
      return LoginResponse(
        token: 'mock_token_${DateTime.now().millisecondsSinceEpoch}',
        user: const User(
          id: 'user_2',
          name: '李四',
          phone: '13900000000',
        ),
        patients: [],
      );
    } else {
      throw const AppError.validation(
        field: 'phone',
        message: '手机号不存在',
      );
    }
  }

  @override
  Future<Patient> createPatient(CreatePatientRequest request) async {
    await Future.delayed(_delay);

    return Patient(
      id: 'patient_${DateTime.now().millisecondsSinceEpoch}',
      name: request.name,
      idNumber: request.idNumber,
      gender: request.gender,
      birthDate: request.birthDate,
      phone: request.phone,
      medicalRecordNumber: request.medicalRecordNumber,
      emergencyContact: request.emergencyContact,
      emergencyContactPhone: request.emergencyContactPhone,
      createdAt: DateTime.now(),
    );
  }
}

// 本地数据源实现
class AuthLocalDataSourceImpl implements AuthLocalDataSource {
  final SharedPreferences _prefs;
  final FlutterSecureStorage _secureStorage;

  static const String _keyToken = 'auth_token';
  static const String _keyUser = 'cached_user';
  static const String _keyTermsAgreed = 'terms_agreed';

  AuthLocalDataSourceImpl(this._prefs, this._secureStorage);

  @override
  Future<String?> getAuthToken() async {
    try {
      return await _secureStorage.read(key: _keyToken);
    } catch (e) {
      Logger.error('Failed to read auth token', e);
      return null;
    }
  }

  @override
  Future<void> saveAuthToken(String token) async {
    try {
      await _secureStorage.write(key: _keyToken, value: token);
    } catch (e) {
      Logger.error('Failed to save auth token', e);
      rethrow;
    }
  }

  @override
  Future<User?> getCachedUser() async {
    try {
      final userJson = _prefs.getString(_keyUser);
      if (userJson != null) {
        return User.fromJson(jsonDecode(userJson));
      }
      return null;
    } catch (e) {
      Logger.error('Failed to get cached user', e);
      return null;
    }
  }

  @override
  Future<bool> hasAgreedToTerms() async {
    return _prefs.getBool(_keyTermsAgreed) ?? false;
  }
}
```

### 3.3 仓库实现

```dart
// 认证仓库接口
abstract class AuthRepository {
  Future<Result<LoginResponse, AppError>> login(LoginRequest request);
  Future<Result<void, AppError>> logout();
  Future<Result<User, AppError>> getCurrentUser();
  Future<Result<List<Patient>, AppError>> getPatients();
  Future<Result<Patient, AppError>> createPatient(CreatePatientRequest request);
  Future<bool> isAuthenticated();
  Future<void> saveAuthState(LoginResponse response);
  Future<void> clearAuthState();
  Future<bool> hasAgreedToTerms();
  Future<void> saveTermsAgreement(bool agreed);
}

// 认证仓库实现
class AuthRepositoryImpl implements AuthRepository {
  final AuthRemoteDataSource _remoteDataSource;
  final AuthLocalDataSource _localDataSource;

  AuthRepositoryImpl(this._remoteDataSource, this._localDataSource);

  @override
  Future<Result<LoginResponse, AppError>> login(LoginRequest request) async {
    try {
      final response = await _remoteDataSource.login(request);
      await saveAuthState(response);
      return Result.success(response);
    } on AppError catch (e) {
      return Result.failure(e);
    } catch (e) {
      return Result.failure(AppError.unknown(message: e.toString(), cause: e));
    }
  }

  @override
  Future<Result<void, AppError>> logout() async {
    try {
      await _remoteDataSource.logout();
      await clearAuthState();
      return const Result.success(null);
    } on AppError catch (e) {
      // 即使远程登出失败，也要清理本地状态
      await clearAuthState();
      return Result.failure(e);
    } catch (e) {
      await clearAuthState();
      return Result.failure(AppError.unknown(message: e.toString(), cause: e));
    }
  }

  @override
  Future<bool> isAuthenticated() async {
    final token = await _localDataSource.getAuthToken();
    return token != null && token.isNotEmpty;
  }

  @override
  Future<void> saveAuthState(LoginResponse response) async {
    await Future.wait([
      _localDataSource.saveAuthToken(response.token),
      _localDataSource.saveCachedUser(response.user),
    ]);
  }

  @override
  Future<void> clearAuthState() async {
    await Future.wait([
      _localDataSource.removeAuthToken(),
      _localDataSource.removeCachedUser(),
    ]);
  }

  @override
  Future<Result<Patient, AppError>> createPatient(CreatePatientRequest request) async {
    try {
      final patient = await _remoteDataSource.createPatient(request);
      return Result.success(patient);
    } on AppError catch (e) {
      return Result.failure(e);
    } catch (e) {
      return Result.failure(AppError.unknown(message: e.toString(), cause: e));
    }
  }
}
```

## 4. 业务逻辑层 (Domain)

### 4.1 用例定义

```dart
// 登录用例
@riverpod
class LoginUseCase extends _$LoginUseCase {
  @override
  void build() {}

  Future<Result<LoginResponse, AppError>> execute(
    String phone, {
    bool agreedToTerms = false,
  }) async {
    // 业务规则验证
    if (!agreedToTerms) {
      return const Result.failure(
        AppError.validation(
          field: 'terms',
          message: '请先同意服务协议和隐私协议',
        ),
      );
    }

    if (!_isValidPhone(phone)) {
      return const Result.failure(
        AppError.validation(
          field: 'phone',
          message: '请输入正确的手机号码',
        ),
      );
    }

    final repository = ref.read(authRepositoryProvider);
    final request = LoginRequest(phone: phone, agreedToTerms: agreedToTerms);

    return await repository.login(request);
  }

  bool _isValidPhone(String phone) {
    final regex = RegExp(r'^1[3-9]\d{9}$');
    return regex.hasMatch(phone);
  }
}

// 自动登录用例
@riverpod
class AutoLoginUseCase extends _$AutoLoginUseCase {
  @override
  void build() {}

  Future<Result<User, AppError>> execute() async {
    final repository = ref.read(authRepositoryProvider);

    final isAuthenticated = await repository.isAuthenticated();
    if (!isAuthenticated) {
      return const Result.failure(
        AppError.authentication(message: '未找到有效的登录凭证'),
      );
    }

    return await repository.getCurrentUser();
  }
}

// 创建患者用例
@riverpod
class CreatePatientUseCase extends _$CreatePatientUseCase {
  @override
  void build() {}

  Future<Result<Patient, AppError>> execute(CreatePatientRequest request) async {
    // 业务规则验证
    final validationResult = _validatePatientData(request);
    if (validationResult.isFailure) {
      return validationResult.cast<Patient>();
    }

    final repository = ref.read(authRepositoryProvider);
    return await repository.createPatient(request);
  }

  Result<void, AppError> _validatePatientData(CreatePatientRequest request) {
    // 姓名验证
    if (request.name.trim().isEmpty) {
      return const Result.failure(
        AppError.validation(field: 'name', message: '请输入真实姓名'),
      );
    }

    // 身份证号验证
    if (!_isValidIdNumber(request.idNumber)) {
      return const Result.failure(
        AppError.validation(field: 'idNumber', message: '请输入正确的身份证号'),
      );
    }

    // 手机号验证
    if (!_isValidPhone(request.phone)) {
      return const Result.failure(
        AppError.validation(field: 'phone', message: '请输入正确的手机号码'),
      );
    }

    // 年龄验证
    final age = DateTime.now().year - request.birthDate.year;
    if (age < 0 || age > 150) {
      return const Result.failure(
        AppError.validation(field: 'birthDate', message: '请输入正确的出生日期'),
      );
    }

    return const Result.success(null);
  }

  bool _isValidIdNumber(String idNumber) {
    final regex = RegExp(r'^\d{17}[\dXx]$');
    return regex.hasMatch(idNumber);
  }

  bool _isValidPhone(String phone) {
    final regex = RegExp(r'^1[3-9]\d{9}$');
    return regex.hasMatch(phone);
  }
}
```

## 5. 表现层架构

### 5.1 状态管理 Providers

```dart
// 认证状态管理
@riverpod
class AuthNotifier extends _$AuthNotifier {
  @override
  AsyncValue<AuthState> build() {
    // 应用启动时尝试自动登录
    _autoLogin();
    return const AsyncValue.loading();
  }

  Future<void> login(String phone) async {
    if (state.isLoading) return;

    state = const AsyncValue.loading();

    final useCase = ref.read(loginUseCaseProvider.notifier);
    final termsAgreed = ref.read(termsAgreementProvider);

    final result = await useCase.execute(phone, agreedToTerms: termsAgreed);

    result.when(
      success: (response) {
        state = AsyncValue.data(AuthState(
          user: response.user,
          patients: response.patients,
          token: response.token,
          isAuthenticated: true,
          hasAgreedToTerms: termsAgreed,
        ));

        // 登录成功后跳转
        ref.read(appRouterProvider).go(AppRoutes.dashboard);
      },
      failure: (error) {
        state = AsyncValue.error(error, StackTrace.current);
      },
    );
  }

  Future<void> logout() async {
    final useCase = ref.read(logoutUseCaseProvider.notifier);
    await useCase.execute();

    state = const AsyncValue.data(AuthState());
    ref.read(appRouterProvider).go(AppRoutes.login);
  }

  Future<void> _autoLogin() async {
    final useCase = ref.read(autoLoginUseCaseProvider.notifier);
    final result = await useCase.execute();

    result.when(
      success: (user) {
        // 获取患者列表
        _loadPatients(user);
      },
      failure: (error) {
        state = const AsyncValue.data(AuthState());
      },
    );
  }

  Future<void> _loadPatients(User user) async {
    try {
      final repository = ref.read(authRepositoryProvider);
      final patientsResult = await repository.getPatients();

      patientsResult.when(
        success: (patients) {
          state = AsyncValue.data(AuthState(
            user: user,
            patients: patients,
            isAuthenticated: true,
            hasAgreedToTerms: true,
          ));
        },
        failure: (error) {
          // 用户信息加载成功但患者列表失败，仍然保持登录状态
          state = AsyncValue.data(AuthState(
            user: user,
            patients: [],
            isAuthenticated: true,
            hasAgreedToTerms: true,
          ));
        },
      );
    } catch (e) {
      state = AsyncValue.error(e, StackTrace.current);
    }
  }
}

// 协议同意状态
@riverpod
class TermsAgreementNotifier extends _$TermsAgreementNotifier {
  @override
  bool build() {
    _loadAgreementState();
    return false;
  }

  void toggle() {
    state = !state;
    _saveAgreementState(state);
  }

  Future<void> _loadAgreementState() async {
    final repository = ref.read(authRepositoryProvider);
    final agreed = await repository.hasAgreedToTerms();
    state = agreed;
  }

  Future<void> _saveAgreementState(bool agreed) async {
    final repository = ref.read(authRepositoryProvider);
    await repository.saveTermsAgreement(agreed);
  }
}

// 患者表单状态管理
@riverpod
class PatientFormNotifier extends _$PatientFormNotifier {
  @override
  PatientFormState build() => const PatientFormState();

  void updateName(String name) {
    state = state.copyWith(name: name);
    _validateForm();
  }

  void updateIdNumber(String idNumber) {
    state = state.copyWith(idNumber: idNumber);
    _validateForm();
  }

  void updateGender(Gender gender) {
    state = state.copyWith(gender: gender);
    _validateForm();
  }

  void updateBirthDate(DateTime birthDate) {
    state = state.copyWith(birthDate: birthDate);
    _validateForm();
  }

  void updatePhone(String phone) {
    state = state.copyWith(phone: phone);
    _validateForm();
  }

  Future<void> submit() async {
    if (!state.validation.isValid || state.isSubmitting) return;

    state = state.copyWith(isSubmitting: true);

    try {
      final request = CreatePatientRequest(
        name: state.name!,
        idNumber: state.idNumber!,
        gender: state.gender!,
        birthDate: state.birthDate!,
        phone: state.phone!,
        medicalRecordNumber: state.medicalRecordNumber,
        emergencyContact: state.emergencyContact,
        emergencyContactPhone: state.emergencyContactPhone,
      );

      final useCase = ref.read(createPatientUseCaseProvider.notifier);
      final result = await useCase.execute(request);

      result.when(
        success: (patient) {
          // 刷新认证状态以包含新患者
          ref.invalidate(authNotifierProvider);
          // 跳转到成功页面
          ref.read(appRouterProvider).go(AppRoutes.patientCreateSuccess);
        },
        failure: (error) {
          final errors = <String, String>{};
          error.maybeWhen(
            validation: (field, message) => errors[field] = message,
            orElse: () => errors['general'] = error.toString(),
          );

          state = state.copyWith(
            validation: FormValidationState(errors: errors, isValid: false),
          );
        },
      );
    } finally {
      state = state.copyWith(isSubmitting: false);
    }
  }

  void _validateForm() {
    final errors = <String, String>{};

    // 验证必填字段
    if (state.name?.trim().isEmpty ?? true) {
      errors['name'] = '请输入真实姓名';
    }

    if (state.idNumber?.isEmpty ?? true) {
      errors['idNumber'] = '请输入身份证号';
    } else if (!_isValidIdNumber(state.idNumber!)) {
      errors['idNumber'] = '请输入正确的身份证号';
    }

    if (state.gender == null) {
      errors['gender'] = '请选择性别';
    }

    if (state.birthDate == null) {
      errors['birthDate'] = '请选择出生日期';
    }

    if (state.phone?.isEmpty ?? true) {
      errors['phone'] = '请输入手机号';
    } else if (!_isValidPhone(state.phone!)) {
      errors['phone'] = '请输入正确的手机号码';
    }

    state = state.copyWith(
      validation: FormValidationState(
        errors: errors,
        isValid: errors.isEmpty,
      ),
    );
  }

  bool _isValidIdNumber(String idNumber) {
    final regex = RegExp(r'^\d{17}[\dXx]$');
    return regex.hasMatch(idNumber);
  }

  bool _isValidPhone(String phone) {
    final regex = RegExp(r'^1[3-9]\d{9}$');
    return regex.hasMatch(phone);
  }
}

// 便利的派生状态
@riverpod
bool isLoggedIn(IsLoggedInRef ref) {
  return ref.watch(authNotifierProvider).maybeWhen(
    data: (state) => state.isAuthenticated,
    orElse: () => false,
  );
}

@riverpod
User? currentUser(CurrentUserRef ref) {
  return ref.watch(authNotifierProvider).maybeWhen(
    data: (state) => state.user,
    orElse: () => null,
  );
}

@riverpod
List<Patient> currentPatients(CurrentPatientsRef ref) {
  return ref.watch(authNotifierProvider).maybeWhen(
    data: (state) => state.patients ?? [],
    orElse: () => [],
  );
}
```

### 5.2 UI 组件设计

```dart
// 登录页面
class LoginScreen extends ConsumerWidget {
  const LoginScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authNotifierProvider);
    final termsAgreed = ref.watch(termsAgreementProvider);

    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              const Spacer(flex: 2),

              // Logo 和标题
              const _LoginHeader(),

              const Spacer(),

              // 登录按钮
              _LoginButton(
                isLoading: authState.isLoading,
                canLogin: termsAgreed,
                onPressed: () => _handleLogin(ref),
              ),

              const SizedBox(height: 16),

              // 协议同意
              _TermsAgreement(
                agreed: termsAgreed,
                onToggle: () => ref.read(termsAgreementProvider.notifier).toggle(),
              ),

              const Spacer(flex: 2),

              // 错误提示
              if (authState.hasError)
                _ErrorMessage(error: authState.error!),
            ],
          ),
        ),
      ),
    );
  }

  void _handleLogin(WidgetRef ref) {
    // Demo 阶段使用固定手机号
    const mockPhone = '13800000000';
    ref.read(authNotifierProvider.notifier).login(mockPhone);
  }
}

// 登录按钮组件
class _LoginButton extends StatelessWidget {
  const _LoginButton({
    required this.isLoading,
    required this.canLogin,
    required this.onPressed,
  });

  final bool isLoading;
  final bool canLogin;
  final VoidCallback onPressed;

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: canLogin && !isLoading ? onPressed : null,
      style: ElevatedButton.styleFrom(
        minimumSize: const Size(double.infinity, 48),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
      child: isLoading
          ? const SizedBox(
              height: 20,
              width: 20,
              child: CircularProgressIndicator(strokeWidth: 2),
            )
          : const Text('一键登录'),
    );
  }
}

// 协议同意组件
class _TermsAgreement extends StatelessWidget {
  const _TermsAgreement({
    required this.agreed,
    required this.onToggle,
  });

  final bool agreed;
  final VoidCallback onToggle;

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Checkbox(
          value: agreed,
          onChanged: (_) => onToggle(),
        ),
        Expanded(
          child: RichText(
            text: TextSpan(
              style: Theme.of(context).textTheme.bodySmall,
              children: [
                const TextSpan(text: '我已阅读并同意'),
                TextSpan(
                  text: '《服务协议》',
                  style: TextStyle(
                    color: Theme.of(context).primaryColor,
                    decoration: TextDecoration.underline,
                  ),
                  recognizer: TapGestureRecognizer()
                    ..onTap = () => _openTerms(context, 'service'),
                ),
                const TextSpan(text: '和'),
                TextSpan(
                  text: '《隐私协议》',
                  style: TextStyle(
                    color: Theme.of(context).primaryColor,
                    decoration: TextDecoration.underline,
                  ),
                  recognizer: TapGestureRecognizer()
                    ..onTap = () => _openTerms(context, 'privacy'),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  void _openTerms(BuildContext context, String type) {
    final url = type == 'service'
        ? 'https://example.com/terms-of-service'
        : 'https://example.com/privacy-policy';

    launchUrl(Uri.parse(url), mode: LaunchMode.externalApplication);
  }
}

// 患者创建表单页面
class CreatePatientScreen extends ConsumerWidget {
  const CreatePatientScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formState = ref.watch(patientFormNotifierProvider);

    return Scaffold(
      appBar: AppBar(title: const Text('添加就诊人')),
      body: Form(
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            // 姓名输入
            TextFormField(
              decoration: const InputDecoration(
                labelText: '真实姓名 *',
                hintText: '请输入真实姓名',
              ),
              textCapitalization: TextCapitalization.words,
              onChanged: (value) => ref
                  .read(patientFormNotifierProvider.notifier)
                  .updateName(value),
              errorText: formState.validation.errors['name'],
            ),

            const SizedBox(height: 16),

            // 身份证号输入
            TextFormField(
              decoration: const InputDecoration(
                labelText: '身份证号 *',
                hintText: '请输入18位身份证号',
              ),
              keyboardType: TextInputType.text,
              maxLength: 18,
              onChanged: (value) => ref
                  .read(patientFormNotifierProvider.notifier)
                  .updateIdNumber(value),
              errorText: formState.validation.errors['idNumber'],
            ),

            const SizedBox(height: 16),

            // 性别选择
            DropdownButtonFormField<Gender>(
              decoration: const InputDecoration(
                labelText: '性别 *',
              ),
              value: formState.gender,
              items: Gender.values.map((gender) {
                return DropdownMenuItem(
                  value: gender,
                  child: Text(gender.label),
                );
              }).toList(),
              onChanged: (gender) {
                if (gender != null) {
                  ref
                      .read(patientFormNotifierProvider.notifier)
                      .updateGender(gender);
                }
              },
              validator: (_) => formState.validation.errors['gender'],
            ),

            const SizedBox(height: 16),

            // 出生日期选择
            InkWell(
              onTap: () => _selectBirthDate(context, ref),
              child: InputDecorator(
                decoration: InputDecoration(
                  labelText: '出生日期 *',
                  errorText: formState.validation.errors['birthDate'],
                ),
                child: Text(
                  formState.birthDate != null
                      ? DateFormat('yyyy年MM月dd日').format(formState.birthDate!)
                      : '请选择出生日期',
                  style: formState.birthDate != null
                      ? null
                      : TextStyle(color: Theme.of(context).hintColor),
                ),
              ),
            ),

            const SizedBox(height: 32),

            // 提交按钮
            ElevatedButton(
              onPressed: formState.validation.isValid && !formState.isSubmitting
                  ? () => ref.read(patientFormNotifierProvider.notifier).submit()
                  : null,
              style: ElevatedButton.styleFrom(
                minimumSize: const Size(double.infinity, 48),
              ),
              child: formState.isSubmitting
                  ? const CircularProgressIndicator()
                  : const Text('确定'),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _selectBirthDate(BuildContext context, WidgetRef ref) async {
    final date = await showDatePicker(
      context: context,
      initialDate: DateTime.now().subtract(const Duration(days: 365 * 30)),
      firstDate: DateTime(1900),
      lastDate: DateTime.now(),
    );

    if (date != null) {
      ref.read(patientFormNotifierProvider.notifier).updateBirthDate(date);
    }
  }
}
```

## 6. TDD 测试策略

### 6.1 测试结构

```
test/features/auth/
├── data/
│   ├── datasources/
│   │   ├── auth_remote_datasource_test.dart
│   │   └── auth_local_datasource_test.dart
│   └── repositories/
│       └── auth_repository_test.dart
├── domain/
│   └── usecases/
│       ├── login_usecase_test.dart
│       ├── auto_login_usecase_test.dart
│       └── create_patient_usecase_test.dart
└── presentation/
    ├── providers/
    │   ├── auth_notifier_test.dart
    │   └── patient_form_notifier_test.dart
    └── screens/
        ├── login_screen_test.dart
        └── create_patient_screen_test.dart
```

### 6.2 核心测试用例

```dart
// 登录用例测试
void main() {
  group('LoginUseCase', () {
    late ProviderContainer container;
    late MockAuthRepository mockRepository;

    setUp(() {
      mockRepository = MockAuthRepository();
      container = ProviderContainer(
        overrides: [
          authRepositoryProvider.overrideWithValue(mockRepository),
        ],
      );
    });

    tearDown(() {
      container.dispose();
    });

    test('should return success when login with valid phone', () async {
      // Given
      const phone = '13800000000';
      final expectedResponse = LoginResponse(
        token: 'test_token',
        user: const User(id: '1', name: 'Test', phone: phone),
        patients: [],
      );

      when(() => mockRepository.login(any()))
          .thenAnswer((_) async => Result.success(expectedResponse));

      // When
      final useCase = container.read(loginUseCaseProvider.notifier);
      final result = await useCase.execute(phone, agreedToTerms: true);

      // Then
      expect(result.isSuccess, true);
      result.when(
        success: (response) {
          expect(response.token, 'test_token');
          expect(response.user.phone, phone);
        },
        failure: (_) => fail('Expected success'),
      );

      verify(() => mockRepository.login(
        const LoginRequest(phone: phone, agreedToTerms: true),
      )).called(1);
    });

    test('should return validation error when terms not agreed', () async {
      // Given
      const phone = '13800000000';

      // When
      final useCase = container.read(loginUseCaseProvider.notifier);
      final result = await useCase.execute(phone, agreedToTerms: false);

      // Then
      expect(result.isFailure, true);
      result.when(
        success: (_) => fail('Expected failure'),
        failure: (error) {
          expect(error, isA<AppError>());
          error.maybeWhen(
            validation: (field, message) {
              expect(field, 'terms');
              expect(message, contains('协议'));
            },
            orElse: () => fail('Expected validation error'),
          );
        },
      );

      verifyNever(() => mockRepository.login(any()));
    });

    test('should return validation error when phone is invalid', () async {
      // Given
      const invalidPhone = '123';

      // When
      final useCase = container.read(loginUseCaseProvider.notifier);
      final result = await useCase.execute(invalidPhone, agreedToTerms: true);

      // Then
      expect(result.isFailure, true);
      result.when(
        success: (_) => fail('Expected failure'),
        failure: (error) {
          error.maybeWhen(
            validation: (field, message) {
              expect(field, 'phone');
              expect(message, contains('手机号'));
            },
            orElse: () => fail('Expected validation error'),
          );
        },
      );
    });
  });
}

// 认证状态管理测试
void main() {
  group('AuthNotifier', () {
    late ProviderContainer container;
    late MockLoginUseCase mockLoginUseCase;
    late MockAutoLoginUseCase mockAutoLoginUseCase;

    setUp(() {
      mockLoginUseCase = MockLoginUseCase();
      mockAutoLoginUseCase = MockAutoLoginUseCase();

      container = ProviderContainer(
        overrides: [
          loginUseCaseProvider.overrideWith(() => mockLoginUseCase),
          autoLoginUseCaseProvider.overrideWith(() => mockAutoLoginUseCase),
          termsAgreementProvider.overrideWith((ref) => true),
        ],
      );
    });

    test('should emit loading then authenticated when login succeeds', () async {
      // Given
      const phone = '13800000000';
      final loginResponse = LoginResponse(
        token: 'test_token',
        user: const User(id: '1', name: 'Test', phone: phone),
        patients: [],
      );

      when(() => mockLoginUseCase.execute(phone, agreedToTerms: true))
          .thenAnswer((_) async => Result.success(loginResponse));

      // When
      final notifier = container.read(authNotifierProvider.notifier);

      // 初始状态应该是 loading
      expect(container.read(authNotifierProvider).isLoading, true);

      await notifier.login(phone);

      // Then
      final finalState = container.read(authNotifierProvider);
      expect(finalState.hasValue, true);

      finalState.whenData((state) {
        expect(state.isAuthenticated, true);
        expect(state.user?.phone, phone);
        expect(state.token, 'test_token');
      });
    });

    test('should emit error when login fails', () async {
      // Given
      const phone = '13800000000';
      const error = AppError.network(message: 'Network error');

      when(() => mockLoginUseCase.execute(phone, agreedToTerms: true))
          .thenAnswer((_) async => const Result.failure(error));

      // When
      final notifier = container.read(authNotifierProvider.notifier);
      await notifier.login(phone);

      // Then
      final finalState = container.read(authNotifierProvider);
      expect(finalState.hasError, true);
      expect(finalState.error, error);
    });
  });
}

// UI 组件测试
void main() {
  group('LoginScreen', () {
    testWidgets('should show login button and terms checkbox', (tester) async {
      // Given
      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            authNotifierProvider.overrideWith(() => MockAuthNotifier()),
            termsAgreementProvider.overrideWith((ref) => false),
          ],
          child: const MaterialApp(home: LoginScreen()),
        ),
      );

      // Then
      expect(find.text('一键登录'), findsOneWidget);
      expect(find.byType(Checkbox), findsOneWidget);
      expect(find.text('《服务协议》'), findsOneWidget);
      expect(find.text('《隐私协议》'), findsOneWidget);

      // 默认情况下登录按钮应该是禁用的
      final loginButton = tester.widget<ElevatedButton>(
        find.widgetWithText(ElevatedButton, '一键登录'),
      );
      expect(loginButton.onPressed, isNull);
    });

    testWidgets('should enable login button when terms are agreed', (tester) async {
      // Given
      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            authNotifierProvider.overrideWith(() => MockAuthNotifier()),
            termsAgreementProvider.overrideWith((ref) => true),
          ],
          child: const MaterialApp(home: LoginScreen()),
        ),
      );

      // Then
      final loginButton = tester.widget<ElevatedButton>(
        find.widgetWithText(ElevatedButton, '一键登录'),
      );
      expect(loginButton.onPressed, isNotNull);
    });

    testWidgets('should toggle terms agreement when checkbox tapped', (tester) async {
      // Given
      final container = ProviderContainer(
        overrides: [
          authNotifierProvider.overrideWith(() => MockAuthNotifier()),
        ],
      );

      await tester.pumpWidget(
        UncontrolledProviderScope(
          container: container,
          child: const MaterialApp(home: LoginScreen()),
        ),
      );

      // When
      await tester.tap(find.byType(Checkbox));
      await tester.pump();

      // Then
      expect(container.read(termsAgreementProvider), true);
    });
  });
}
```

## 7. 集成和部署

### 7.1 Provider 注册

```dart
// main.dart
void main() {
  runApp(
    ProviderScope(
      child: MyApp(),
    ),
  );
}

// app.dart
class MyApp extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final router = ref.watch(appRouterProvider);

    return MaterialApp.router(
      title: 'Vitals Health',
      routerConfig: router,
      builder: (context, child) {
        return _AppWrapper(child: child!);
      },
    );
  }
}

// 应用包装器，用于全局错误处理等
class _AppWrapper extends ConsumerWidget {
  const _AppWrapper({required this.child});

  final Widget child;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 监听全局错误
    ref.listen(authNotifierProvider, (previous, next) {
      next.whenOrNull(
        error: (error, stackTrace) {
          // 显示错误提示
          _showErrorSnackBar(context, error);
        },
      );
    });

    return child;
  }

  void _showErrorSnackBar(BuildContext context, Object error) {
    String message = '操作失败，请重试';

    if (error is AppError) {
      error.maybeWhen(
        network: (msg, _) => message = msg,
        validation: (_, msg) => message = msg,
        authentication: (msg) => message = msg,
        orElse: () => message = error.toString(),
      );
    }

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message)),
    );
  }
}
```

### 7.2 环境配置

```dart
// config/app_config.dart
class AppConfig {
  static const String apiBaseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'https://api.vitals.example.com',
  );

  static const bool useMockApi = bool.fromEnvironment(
    'USE_MOCK_API',
    defaultValue: false,
  );

  static const bool enableLogging = bool.fromEnvironment(
    'ENABLE_LOGGING',
    defaultValue: true,
  );
}

// Provider 环境配置
@riverpod
Environment appEnvironment(AppEnvironmentRef ref) {
  if (AppConfig.useMockApi) {
    return Environment.development;
  }

  if (kDebugMode) {
    return Environment.staging;
  }

  return Environment.production;
}
```

这个架构设计完整覆盖了用户认证模块的所有需求，开发者可以按照文档进行 TDD 开发，确保代码质量和功能完整性。
