# 健康数据模块架构设计

## 1. 模块概述

### 1.1 功能描述
健康数据模块负责管理各类健康指标的记录、查看和分析，包括血压、心率、体重、步数等核心指标的详情展示、历史趋势分析和手动数据录入。

### 1.2 核心功能
- **血压管理**: 血压数据的记录、趋势图表展示、分类评估
- **心率监测**: 心率数据的跟踪和区间分析
- **体重管理**: 体重记录、BMI计算、变化趋势
- **运动数据**: 步数统计、距离计算、卡路里消耗
- **数据录入**: 自定义键盘、表单验证、批量录入
- **图表分析**: 多时间维度的趋势图表展示

### 1.3 技术要求
- 基于 TDD 开发，完整测试覆盖
- 支持离线数据缓存和同步
- 高性能图表渲染（fl_chart）
- 响应式设计和自定义UI组件

## 2. 数据模型设计

### 2.1 核心实体模型

```dart
// 血压记录
@freezed
class BloodPressureRecord with _$BloodPressureRecord {
  const factory BloodPressureRecord({
    required String id,
    required String patientId,
    required int systolic,
    required int diastolic,
    required DateTime recordedAt,
    int? heartRate,
    String? notes,
    BloodPressureLevel? level,
    MeasurementSource? source,
  }) = _BloodPressureRecord;

  factory BloodPressureRecord.fromJson(Map<String, dynamic> json) =>
      _$BloodPressureRecordFromJson(json);

  const BloodPressureRecord._();

  // 计算血压水平
  BloodPressureLevel get calculatedLevel {
    if (systolic >= 180 || diastolic >= 110) return BloodPressureLevel.crisis;
    if (systolic >= 140 || diastolic >= 90) return BloodPressureLevel.stage2;
    if (systolic >= 130 || diastolic >= 80) return BloodPressureLevel.stage1;
    if (systolic >= 120) return BloodPressureLevel.elevated;
    return BloodPressureLevel.normal;
  }
}

// 心率记录
@freezed
class HeartRateRecord with _$HeartRateRecord {
  const factory HeartRateRecord({
    required String id,
    required String patientId,
    required int bpm,
    required DateTime recordedAt,
    HeartRateZone? zone,
    String? notes,
    MeasurementSource? source,
  }) = _HeartRateRecord;

  factory HeartRateRecord.fromJson(Map<String, dynamic> json) =>
      _$HeartRateRecordFromJson(json);
}

// 体重记录
@freezed
class WeightRecord with _$WeightRecord {
  const factory WeightRecord({
    required String id,
    required String patientId,
    required double weight,
    required DateTime recordedAt,
    double? height, // 身高用于计算BMI
    double? bodyFat,
    String? notes,
  }) = _WeightRecord;

  factory WeightRecord.fromJson(Map<String, dynamic> json) =>
      _$WeightRecordFromJson(json);

  const WeightRecord._();

  // 计算BMI
  double? get bmi {
    if (height == null || height! <= 0) return null;
    return weight / ((height! / 100) * (height! / 100));
  }

  // BMI分类
  BMICategory? get bmiCategory {
    final bmiValue = bmi;
    if (bmiValue == null) return null;

    if (bmiValue < 18.5) return BMICategory.underweight;
    if (bmiValue < 25) return BMICategory.normal;
    if (bmiValue < 30) return BMICategory.overweight;
    return BMICategory.obese;
  }
}

// 数据录入请求
@freezed
class RecordHealthDataRequest with _$RecordHealthDataRequest {
  const factory RecordHealthDataRequest.bloodPressure({
    required int systolic,
    required int diastolic,
    int? heartRate,
    DateTime? recordedAt,
    String? notes,
  }) = _BloodPressureRequest;

  const factory RecordHealthDataRequest.heartRate({
    required int bpm,
    DateTime? recordedAt,
    String? notes,
  }) = _HeartRateRequest;

  const factory RecordHealthDataRequest.weight({
    required double weight,
    DateTime? recordedAt,
    String? notes,
  }) = _WeightRequest;
}

// 图表数据
@freezed
class ChartData with _$ChartData {
  const factory ChartData({
    required List<DataPoint> dataPoints,
    required TimeRange timeRange,
    double? minValue,
    double? maxValue,
    double? averageValue,
    String? trend, // "rising", "falling", "stable"
  }) = _ChartData;
}

@freezed
class DataPoint with _$DataPoint {
  const factory DataPoint({
    required DateTime timestamp,
    required double value,
    double? secondaryValue, // 用于血压的舒张压
    Map<String, dynamic>? metadata,
  }) = _DataPoint;
}

// 时间范围枚举
enum TimeRange {
  week('近一周', 7),
  month('近一月', 30),
  threeMonths('近三月', 90),
  year('近一年', 365),
  all('全部', -1);

  const TimeRange(this.label, this.days);
  final String label;
  final int days;
}
```

### 2.2 状态模型

```dart
// 血压模块状态
@freezed
class BloodPressureState with _$BloodPressureState {
  const factory BloodPressureState({
    @Default([]) List<BloodPressureRecord> records,
    @Default(TimeRange.month) TimeRange selectedRange,
    ChartData? chartData,
    @Default(false) bool isLoading,
    @Default(false) bool isRecording,
    String? error,
  }) = _BloodPressureState;

  const BloodPressureState._();

  List<BloodPressureRecord> get filteredRecords {
    if (selectedRange == TimeRange.all) return records;

    final cutoffDate = DateTime.now().subtract(Duration(days: selectedRange.days));
    return records.where((record) => record.recordedAt.isAfter(cutoffDate)).toList();
  }

  BloodPressureRecord? get latestRecord =>
      records.isNotEmpty ? records.first : null;
}

// 数据录入状态
@freezed
class DataEntryState with _$DataEntryState {
  const factory DataEntryState({
    int? systolic,
    int? diastolic,
    int? heartRate,
    double? weight,
    DateTime? recordedAt,
    String? notes,
    @Default({}) Map<String, String> validationErrors,
    @Default(false) bool isSubmitting,
  }) = _DataEntryState;

  const DataEntryState._();

  bool get isValid => validationErrors.isEmpty;
  bool get hasBloodPressureData => systolic != null && diastolic != null;
  bool get hasHeartRateData => heartRate != null;
  bool get hasWeightData => weight != null;
}
```

## 3. 数据层架构

### 3.1 数据源设计

```dart
// 健康数据远程数据源
abstract class HealthDataRemoteDataSource {
  // 获取血压记录
  Future<List<BloodPressureRecord>> getBloodPressureRecords(
    String patientId, {
    TimeRange? range,
  });

  // 添加血压记录
  Future<BloodPressureRecord> addBloodPressureRecord(
    String patientId,
    RecordHealthDataRequest request,
  );

  // 获取图表数据
  Future<ChartData> getBloodPressureChartData(
    String patientId,
    TimeRange range,
  );

  // 类似的心率、体重接口...
}

// Mock 实现 - 生成测试数据
class HealthDataRemoteDataSourceMock implements HealthDataRemoteDataSource {
  @override
  Future<List<BloodPressureRecord>> getBloodPressureRecords(
    String patientId, {
    TimeRange? range,
  }) async {
    await Future.delayed(const Duration(milliseconds: 800));

    // 生成模拟数据
    return _generateMockBloodPressureData(range ?? TimeRange.month);
  }

  List<BloodPressureRecord> _generateMockBloodPressureData(TimeRange range) {
    final records = <BloodPressureRecord>[];
    final now = DateTime.now();
    final days = range == TimeRange.all ? 90 : range.days;

    for (int i = 0; i < days; i += 2) {
      final date = now.subtract(Duration(days: i));

      // 模拟血压波动
      final baseSystolic = 125 + (math.Random().nextDouble() - 0.5) * 20;
      final baseDiastolic = 80 + (math.Random().nextDouble() - 0.5) * 15;

      records.add(BloodPressureRecord(
        id: 'bp_${date.millisecondsSinceEpoch}',
        patientId: patientId,
        systolic: baseSystolic.round(),
        diastolic: baseDiastolic.round(),
        recordedAt: date,
        heartRate: (70 + (math.Random().nextDouble() - 0.5) * 20).round(),
        source: MeasurementSource.manual,
      ));
    }

    return records..sort((a, b) => b.recordedAt.compareTo(a.recordedAt));
  }
}

// 本地数据源 - 缓存和离线支持
class HealthDataLocalDataSourceImpl implements HealthDataLocalDataSource {
  final SharedPreferences _prefs;

  @override
  Future<List<BloodPressureRecord>> getCachedBloodPressureRecords(
    String patientId,
  ) async {
    final key = 'bp_records_$patientId';
    final jsonString = _prefs.getString(key);

    if (jsonString != null) {
      final List<dynamic> jsonList = jsonDecode(jsonString);
      return jsonList.map((json) => BloodPressureRecord.fromJson(json)).toList();
    }

    return [];
  }

  @override
  Future<void> cacheBloodPressureRecords(
    String patientId,
    List<BloodPressureRecord> records,
  ) async {
    final key = 'bp_records_$patientId';
    final jsonString = jsonEncode(records.map((r) => r.toJson()).toList());
    await _prefs.setString(key, jsonString);
  }
}
```

### 3.2 仓库实现

```dart
// 健康数据仓库
class HealthDataRepositoryImpl implements HealthDataRepository {
  final HealthDataRemoteDataSource _remoteDataSource;
  final HealthDataLocalDataSource _localDataSource;

  @override
  Future<Result<List<BloodPressureRecord>, AppError>> getBloodPressureRecords(
    String patientId, {
    TimeRange? range,
    bool forceRefresh = false,
  }) async {
    try {
      // 离线优先策略
      if (!forceRefresh) {
        final cachedRecords = await _localDataSource
            .getCachedBloodPressureRecords(patientId);

        if (cachedRecords.isNotEmpty) {
          return Result.success(cachedRecords);
        }
      }

      // 从远程获取数据
      final remoteRecords = await _remoteDataSource
          .getBloodPressureRecords(patientId, range: range);

      // 缓存到本地
      await _localDataSource.cacheBloodPressureRecords(patientId, remoteRecords);

      return Result.success(remoteRecords);
    } catch (e) {
      // 网络错误时返回缓存数据
      final cachedRecords = await _localDataSource
          .getCachedBloodPressureRecords(patientId);

      if (cachedRecords.isNotEmpty) {
        return Result.success(cachedRecords);
      }

      return Result.failure(AppError.network(message: e.toString()));
    }
  }

  @override
  Future<Result<BloodPressureRecord, AppError>> addBloodPressureRecord(
    String patientId,
    RecordHealthDataRequest request,
  ) async {
    try {
      final record = await _remoteDataSource
          .addBloodPressureRecord(patientId, request);

      // 更新本地缓存
      final cachedRecords = await _localDataSource
          .getCachedBloodPressureRecords(patientId);
      cachedRecords.insert(0, record);
      await _localDataSource.cacheBloodPressureRecords(patientId, cachedRecords);

      return Result.success(record);
    } catch (e) {
      return Result.failure(AppError.network(message: e.toString()));
    }
  }
}
```

## 4. 业务逻辑层

### 4.1 用例定义

```dart
// 获取血压数据用例
@riverpod
class GetBloodPressureDataUseCase extends _$GetBloodPressureDataUseCase {
  Future<Result<List<BloodPressureRecord>, AppError>> execute(
    String patientId, {
    TimeRange? range,
    bool forceRefresh = false,
  }) async {
    final repository = ref.read(healthDataRepositoryProvider);
    return repository.getBloodPressureRecords(
      patientId,
      range: range,
      forceRefresh: forceRefresh,
    );
  }
}

// 记录血压数据用例
@riverpod
class RecordBloodPressureUseCase extends _$RecordBloodPressureUseCase {
  Future<Result<BloodPressureRecord, AppError>> execute(
    String patientId,
    int systolic,
    int diastolic, {
    int? heartRate,
    DateTime? recordedAt,
    String? notes,
  }) async {
    // 业务验证
    final validationResult = _validateBloodPressureData(systolic, diastolic);
    if (validationResult.isFailure) {
      return validationResult.cast<BloodPressureRecord>();
    }

    final request = RecordHealthDataRequest.bloodPressure(
      systolic: systolic,
      diastolic: diastolic,
      heartRate: heartRate,
      recordedAt: recordedAt ?? DateTime.now(),
      notes: notes,
    );

    final repository = ref.read(healthDataRepositoryProvider);
    return repository.addBloodPressureRecord(patientId, request);
  }

  Result<void, AppError> _validateBloodPressureData(int systolic, int diastolic) {
    if (systolic <= 0 || systolic > 300) {
      return const Result.failure(
        AppError.validation(field: 'systolic', message: '收缩压范围无效'),
      );
    }

    if (diastolic <= 0 || diastolic > 200) {
      return const Result.failure(
        AppError.validation(field: 'diastolic', message: '舒张压范围无效'),
      );
    }

    if (systolic <= diastolic) {
      return const Result.failure(
        AppError.validation(field: 'pressure', message: '收缩压应大于舒张压'),
      );
    }

    return const Result.success(null);
  }
}

// 生成图表数据用例
@riverpod
class GenerateChartDataUseCase extends _$GenerateChartDataUseCase {
  ChartData execute(List<BloodPressureRecord> records, TimeRange range) {
    if (records.isEmpty) {
      return const ChartData(dataPoints: [], timeRange: TimeRange.month);
    }

    final dataPoints = records.map((record) => DataPoint(
      timestamp: record.recordedAt,
      value: record.systolic.toDouble(),
      secondaryValue: record.diastolic.toDouble(),
    )).toList();

    // 计算统计信息
    final systolicValues = dataPoints.map((p) => p.value).toList();
    final avgSystolic = systolicValues.reduce((a, b) => a + b) / systolicValues.length;

    // 分析趋势
    final trend = _analyzeTrend(dataPoints);

    return ChartData(
      dataPoints: dataPoints,
      timeRange: range,
      minValue: systolicValues.reduce(math.min),
      maxValue: systolicValues.reduce(math.max),
      averageValue: avgSystolic,
      trend: trend,
    );
  }

  String _analyzeTrend(List<DataPoint> points) {
    if (points.length < 2) return 'stable';

    // 简单的线性趋势分析
    final first = points.last.value;
    final last = points.first.value;
    final difference = last - first;

    if (difference > 5) return 'rising';
    if (difference < -5) return 'falling';
    return 'stable';
  }
}
```

## 5. 表现层架构

### 5.1 状态管理

```dart
// 血压页面状态管理
@riverpod
class BloodPressureNotifier extends _$BloodPressureNotifier {
  @override
  AsyncValue<BloodPressureState> build() {
    _loadBloodPressureData();
    return const AsyncValue.loading();
  }

  Future<void> refresh() async {
    await _loadBloodPressureData(forceRefresh: true);
  }

  void changeTimeRange(TimeRange range) {
    state.whenData((currentState) {
      state = AsyncValue.data(currentState.copyWith(selectedRange: range));
      _updateChartData();
    });
  }

  Future<void> addRecord(int systolic, int diastolic, {int? heartRate}) async {
    final patients = ref.read(currentPatientsProvider);
    if (patients.isEmpty) return;

    final patientId = patients.first.id;

    state.whenData((currentState) {
      state = AsyncValue.data(currentState.copyWith(isRecording: true));
    });

    final useCase = ref.read(recordBloodPressureUseCaseProvider.notifier);
    final result = await useCase.execute(
      patientId,
      systolic,
      diastolic,
      heartRate: heartRate,
    );

    result.when(
      success: (record) {
        state.whenData((currentState) {
          final updatedRecords = [record, ...currentState.records];
          state = AsyncValue.data(currentState.copyWith(
            records: updatedRecords,
            isRecording: false,
          ));
          _updateChartData();
        });
      },
      failure: (error) {
        state.whenData((currentState) {
          state = AsyncValue.data(currentState.copyWith(
            isRecording: false,
            error: error.toString(),
          ));
        });
      },
    );
  }

  Future<void> _loadBloodPressureData({bool forceRefresh = false}) async {
    final patients = ref.read(currentPatientsProvider);
    if (patients.isEmpty) return;

    final patientId = patients.first.id;
    final useCase = ref.read(getBloodPressureDataUseCaseProvider.notifier);

    final result = await useCase.execute(
      patientId,
      forceRefresh: forceRefresh,
    );

    result.when(
      success: (records) {
        state = AsyncValue.data(BloodPressureState(records: records));
        _updateChartData();
      },
      failure: (error) {
        state = AsyncValue.error(error, StackTrace.current);
      },
    );
  }

  void _updateChartData() {
    state.whenData((currentState) {
      final chartUseCase = ref.read(generateChartDataUseCaseProvider.notifier);
      final chartData = chartUseCase.execute(
        currentState.filteredRecords,
        currentState.selectedRange,
      );

      state = AsyncValue.data(currentState.copyWith(chartData: chartData));
    });
  }
}

// 数据录入表单状态
@riverpod
class DataEntryNotifier extends _$DataEntryNotifier {
  @override
  DataEntryState build() => const DataEntryState();

  void updateSystolic(int? value) {
    state = state.copyWith(systolic: value);
    _validateForm();
  }

  void updateDiastolic(int? value) {
    state = state.copyWith(diastolic: value);
    _validateForm();
  }

  void updateHeartRate(int? value) {
    state = state.copyWith(heartRate: value);
  }

  void _validateForm() {
    final errors = <String, String>{};

    if (state.systolic != null && (state.systolic! <= 0 || state.systolic! > 300)) {
      errors['systolic'] = '收缩压范围：1-300';
    }

    if (state.diastolic != null && (state.diastolic! <= 0 || state.diastolic! > 200)) {
      errors['diastolic'] = '舒张压范围：1-200';
    }

    if (state.systolic != null && state.diastolic != null &&
        state.systolic! <= state.diastolic!) {
      errors['pressure'] = '收缩压应大于舒张压';
    }

    state = state.copyWith(validationErrors: errors);
  }

  void reset() {
    state = const DataEntryState();
  }
}
```

### 5.2 UI 组件设计

```dart
// 血压详情页面
class BloodPressureScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final bloodPressureState = ref.watch(bloodPressureNotifierProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('血压管理'),
        actions: [
          _TimeRangeSelector(),
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () => ref.read(bloodPressureNotifierProvider.notifier).refresh(),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showAddRecordDialog(context),
        child: const Icon(Icons.add),
      ),
      body: bloodPressureState.when(
        loading: () => const LoadingView(),
        error: (error, _) => ErrorView(error: error),
        data: (state) => _BloodPressureContent(state: state),
      ),
    );
  }

  void _showAddRecordDialog(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => const BloodPressureInputDialog(),
    );
  }
}

// 血压内容视图
class _BloodPressureContent extends StatelessWidget {
  const _BloodPressureContent({required this.state});

  final BloodPressureState state;

  @override
  Widget build(BuildContext context) {
    return RefreshIndicator(
      onRefresh: () => context.read(bloodPressureNotifierProvider.notifier).refresh(),
      child: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // 最新数据卡片
          if (state.latestRecord != null)
            _LatestRecordCard(record: state.latestRecord!),

          const SizedBox(height: 16),

          // 趋势图表
          if (state.chartData != null)
            _BloodPressureChart(chartData: state.chartData!),

          const SizedBox(height: 16),

          // 历史记录列表
          _RecordsList(records: state.filteredRecords),
        ],
      ),
    );
  }
}

// 血压趋势图表
class _BloodPressureChart extends StatelessWidget {
  const _BloodPressureChart({required this.chartData});

  final ChartData chartData;

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '血压趋势',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 16),

            // fl_chart 图表
            SizedBox(
              height: 200,
              child: LineChart(
                LineChartData(
                  gridData: const FlGridData(show: true),
                  titlesData: _buildTitlesData(),
                  lineBarsData: _buildLineBarsData(),
                  // 图表配置...
                ),
              ),
            ),

            const SizedBox(height: 12),

            // 统计信息
            _ChartStatistics(chartData: chartData),
          ],
        ),
      ),
    );
  }

  List<LineChartBarData> _buildLineBarsData() {
    return [
      // 收缩压线
      LineChartBarData(
        spots: chartData.dataPoints.map((point) => FlSpot(
          point.timestamp.millisecondsSinceEpoch.toDouble(),
          point.value,
        )).toList(),
        color: Colors.red,
        barWidth: 2,
      ),
      // 舒张压线
      LineChartBarData(
        spots: chartData.dataPoints.map((point) => FlSpot(
          point.timestamp.millisecondsSinceEpoch.toDouble(),
          point.secondaryValue ?? 0,
        )).toList(),
        color: Colors.blue,
        barWidth: 2,
      ),
    ];
  }
}

// 数据录入对话框
class BloodPressureInputDialog extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final entryState = ref.watch(dataEntryNotifierProvider);

    return Padding(
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      child: Container(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              '记录血压',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 24),

            // 自定义数字键盘输入
            _BloodPressureInputFields(),

            const SizedBox(height: 24),

            // 提交按钮
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: entryState.isValid ? () => _submitData(context, ref) : null,
                child: entryState.isSubmitting
                    ? const CircularProgressIndicator()
                    : const Text('保存'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _submitData(BuildContext context, WidgetRef ref) async {
    final entryState = ref.read(dataEntryNotifierProvider);

    if (entryState.hasBloodPressureData) {
      await ref.read(bloodPressureNotifierProvider.notifier).addRecord(
        entryState.systolic!,
        entryState.diastolic!,
        heartRate: entryState.heartRate,
      );

      ref.read(dataEntryNotifierProvider.notifier).reset();
      Navigator.of(context).pop();
    }
  }
}

// 自定义数字键盘
class _BloodPressureInputFields extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final entryState = ref.watch(dataEntryNotifierProvider);

    return Column(
      children: [
        Row(
          children: [
            Expanded(
              child: _NumericInputField(
                label: '收缩压',
                value: entryState.systolic,
                onChanged: (value) => ref
                    .read(dataEntryNotifierProvider.notifier)
                    .updateSystolic(value),
                errorText: entryState.validationErrors['systolic'],
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: _NumericInputField(
                label: '舒张压',
                value: entryState.diastolic,
                onChanged: (value) => ref
                    .read(dataEntryNotifierProvider.notifier)
                    .updateDiastolic(value),
                errorText: entryState.validationErrors['diastolic'],
              ),
            ),
          ],
        ),

        if (entryState.validationErrors['pressure'] != null) ...[
          const SizedBox(height: 8),
          Text(
            entryState.validationErrors['pressure']!,
            style: TextStyle(color: Theme.of(context).colorScheme.error),
          ),
        ],

        const SizedBox(height: 16),

        // 心率输入（可选）
        _NumericInputField(
          label: '心率（可选）',
          value: entryState.heartRate,
          onChanged: (value) => ref
              .read(dataEntryNotifierProvider.notifier)
              .updateHeartRate(value),
        ),
      ],
    );
  }
}

// 数字输入字段
class _NumericInputField extends StatelessWidget {
  const _NumericInputField({
    required this.label,
    required this.value,
    required this.onChanged,
    this.errorText,
  });

  final String label;
  final int? value;
  final ValueChanged<int?> onChanged;
  final String? errorText;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: Theme.of(context).textTheme.bodyMedium),
        const SizedBox(height: 8),

        // 自定义数字显示和输入
        Container(
          height: 60,
          decoration: BoxDecoration(
            border: Border.all(
              color: errorText != null
                  ? Theme.of(context).colorScheme.error
                  : Theme.of(context).colorScheme.outline,
            ),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Text(
              value?.toString() ?? '--',
              style: Theme.of(context).textTheme.headlineMedium,
            ),
          ),
        ),

        if (errorText != null) ...[
          const SizedBox(height: 4),
          Text(
            errorText!,
            style: TextStyle(
              color: Theme.of(context).colorScheme.error,
              fontSize: 12,
            ),
          ),
        ],

        const SizedBox(height: 8),

        // 数字键盘
        _CustomNumericKeypad(
          onNumberPressed: (number) {
            final currentValue = value ?? 0;
            final newValue = currentValue * 10 + number;
            if (newValue <= 999) {
              onChanged(newValue);
            }
          },
          onBackspace: () {
            if (value != null) {
              final newValue = value! ~/ 10;
              onChanged(newValue == 0 ? null : newValue);
            }
          },
        ),
      ],
    );
  }
}
```

## 6. TDD 测试策略

### 6.1 关键测试用例

```dart
// 血压数据用例测试
void main() {
  group('RecordBloodPressureUseCase', () {
    late ProviderContainer container;
    late MockHealthDataRepository mockRepository;

    setUp(() {
      mockRepository = MockHealthDataRepository();
      container = ProviderContainer(
        overrides: [
          healthDataRepositoryProvider.overrideWithValue(mockRepository),
        ],
      );
    });

    test('should validate blood pressure data correctly', () async {
      // Given
      const patientId = 'patient_1';

      // When - 有效数据
      final useCase = container.read(recordBloodPressureUseCaseProvider.notifier);
      final validResult = await useCase.execute(patientId, 120, 80);

      // Then
      expect(validResult.isSuccess, true);

      // When - 无效数据：收缩压小于舒张压
      final invalidResult = await useCase.execute(patientId, 80, 120);

      // Then
      expect(invalidResult.isFailure, true);
      invalidResult.when(
        success: (_) => fail('Expected validation error'),
        failure: (error) {
          expect(error, isA<AppError>());
          error.maybeWhen(
            validation: (field, message) {
              expect(field, 'pressure');
              expect(message, contains('收缩压应大于舒张压'));
            },
            orElse: () => fail('Expected validation error'),
          );
        },
      );
    });
  });
}

// 图表数据生成测试
void main() {
  group('GenerateChartDataUseCase', () {
    test('should generate correct chart data from records', () {
      // Given
      final records = [
        BloodPressureRecord(
          id: '1',
          patientId: 'patient_1',
          systolic: 120,
          diastolic: 80,
          recordedAt: DateTime(2024, 1, 1),
        ),
        BloodPressureRecord(
          id: '2',
          patientId: 'patient_1',
          systolic: 130,
          diastolic: 85,
          recordedAt: DateTime(2024, 1, 2),
        ),
      ];

      // When
      final container = ProviderContainer();
      final useCase = container.read(generateChartDataUseCaseProvider.notifier);
      final chartData = useCase.execute(records, TimeRange.week);

      // Then
      expect(chartData.dataPoints.length, 2);
      expect(chartData.minValue, 120);
      expect(chartData.maxValue, 130);
      expect(chartData.averageValue, 125);
      expect(chartData.trend, 'rising');
    });
  });
}
```

## 7. 性能优化策略

### 7.1 图表渲染优化

```dart
// 数据采样 - 大数据量时进行采样显示
class ChartDataOptimizer {
  static const int maxDataPoints = 100;

  static List<DataPoint> optimizeDataPoints(List<DataPoint> originalPoints) {
    if (originalPoints.length <= maxDataPoints) {
      return originalPoints;
    }

    // 使用时间间隔采样
    final step = originalPoints.length / maxDataPoints;
    final optimizedPoints = <DataPoint>[];

    for (int i = 0; i < originalPoints.length; i += step.ceil()) {
      optimizedPoints.add(originalPoints[i]);
    }

    return optimizedPoints;
  }
}

// 图表组件懒加载
class LazyLoadChart extends StatefulWidget {
  @override
  State<LazyLoadChart> createState() => _LazyLoadChartState();
}

class _LazyLoadChartState extends State<LazyLoadChart> {
  bool _isVisible = false;

  @override
  Widget build(BuildContext context) {
    return VisibilityDetector(
      key: const Key('chart'),
      onVisibilityChanged: (info) {
        if (info.visibleFraction > 0.5 && !_isVisible) {
          setState(() => _isVisible = true);
        }
      },
      child: _isVisible
          ? ActualChart()
          : Container(height: 200, child: const Center(child: Text('图表加载中...'))),
    );
  }
}
```

### 7.2 数据缓存分层

```dart
// 多层缓存策略
class HealthDataCacheManager {
  // L1: 内存缓存 - 最近访问的数据
  static final _memoryCache = <String, CachedHealthData>{};

  // L2: SQLite缓存 - 大量历史数据
  static late Database _database;

  // L3: SharedPreferences - 配置和元数据
  static late SharedPreferences _prefs;

  static Future<List<BloodPressureRecord>?> getBloodPressureRecords(
    String patientId,
    TimeRange range,
  ) async {
    final cacheKey = '${patientId}_${range.name}';

    // 检查内存缓存
    final memoryData = _memoryCache[cacheKey];
    if (memoryData != null && !memoryData.isExpired) {
      return memoryData.bloodPressureRecords;
    }

    // 检查数据库缓存
    final dbData = await _getFromDatabase(patientId, range);
    if (dbData != null) {
      _memoryCache[cacheKey] = CachedHealthData(
        bloodPressureRecords: dbData,
        cachedAt: DateTime.now(),
      );
      return dbData;
    }

    return null;
  }
}
```

这个健康数据模块架构设计涵盖了血压、心率、体重等各类健康指标的完整管理流程，提供了高性能的图表展示和用户友好的数据录入体验。开发者可以基于这个架构进行模块化开发。
